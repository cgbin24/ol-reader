
![chapter17.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/420fdb2edab64321ac40103b13c092f8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

### 简介

首先，我们看下这张时序图：

![链路图.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed01bd4acc8454699b8b218969c35dd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

它包括了两个主干链路：`节点连通链路`和`消息处理链路`。

- **节点连通链路**：在**中间层之容器**章节中，我们已经介绍了容器内部是如何发现服务，并且调用`kim.Dialer`接口中的`DialAndHandshake`方法实现**连接与握手**。同时在逻辑服务端`Accept`回调中就要处理网关发送的`握手包`。

- **消息处理链路**：

  - 从SDK端出发，会有一个登录的过程。之后就是消息的发送，到达网关的Server端之后，通过消息监听器`Receive`回调给了业务层处理器`handler`，在`handler.Receive`方法中，传入的[]byte数据会被解包成**LogicPkt**对象，然后通过容器的调度转发到`Chat`服务中。
  - 在Chat中也是同样的逻辑，消息被`Server`回调给`handler.Receive`处理之后，就会调用指令路由器`Router`的`Serve`方法处理这条消息。在逻辑服务启动时，会把`指令处理器`注册到`Router`中，所以在`Router.Serve`方法内部可以根据消息头中的`Command`查找到对应的指令处理器。

其中**SDK的登录逻辑将会在下一章节介绍**，上图画的login部分只是为了帮助读者理解完整的逻辑时序。而图中的`红色及高亮的模块与方法`才是本章介绍的主要内容。

### 节点连通链路

![节点连通链路.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6159760ccd314e6b9b1e08ac17b09d1b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

节点指一个具体的服务，如Gateway和Chat。它们之间的连接是**基于内网可靠性设计，因此在这里并没有做复杂的权限认证**，这一点在我们介绍通信层时已经提及过。对Server端（如Chat）来说，它只需要知道`新的连接是谁`，也就是有一个唯一的ServiceID即可。

#### 网关Dialer

我们看看在网关中实现的Dialer，用于服务之间的连接建立。
```go
// services/gateway/serv/dialer.go

package serv

import (
	"net"

	"github.com/klintcheng/kim"
	"github.com/klintcheng/kim/logger"
	"github.com/klintcheng/kim/tcp"
	"github.com/klintcheng/kim/wire/pkt"
	"google.golang.org/protobuf/proto"
)

type TcpDialer struct {
	ServiceId string
}

func NewDialer(serviceId string) kim.Dialer {
	return &TcpDialer{
		ServiceId: serviceId,
	}
}

// DialAndHandshake(context.Context, string) (net.Conn, error)
func (d *TcpDialer) DialAndHandshake(ctx kim.DialerContext) (net.Conn, error) {
	// 1. 拨号建立连接
	conn, err := net.DialTimeout("tcp", ctx.Address, ctx.Timeout)
	if err != nil {
		return nil, err
	}
	req := &pkt.InnerHandshakeReq{
		ServiceId: d.ServiceId,
	}
	logger.Infof("send req %v", req)
	// 2. 把自己的ServiceId发送给对方
	bts, _ := proto.Marshal(req)
	err = tcp.WriteFrame(conn, kim.OpBinary, bts)
	if err != nil {
		return nil, err
	}
	return conn, nil
}
```

逻辑很简单，主要有两步：

1. 拨号建立连。
2. 把自己的ServiceId发送给对方。

基本上只要ServiceId没有重复就不会出问题，否则服务端会关闭连接，容器中就会把新创建的这个Client删除。

#### 逻辑服务Accept

在逻辑服务如chat中，则读取Gateway发过来的消息，并且把`req.ServiceId`当作ChannelId返回。
```go
// services/gateway/serv/handler.go

func (h *ServHandler) Accept(conn kim.Conn, timeout time.Duration) (string, error) {
	log.Infoln("enter")

	_ = conn.SetReadDeadline(time.Now().Add(timeout))
	frame, err := conn.ReadFrame()
	if err != nil {
		return "", err
	}

	var req pkt.InnerHandshakeReq
	_ = proto.Unmarshal(frame.GetPayload(), &req)
	log.Info("Accept -- ", req.ServiceId)

	return req.ServiceId, nil
}
```

### 消息处理链路

如下是消息处理链路时序图：

![消息处理链路.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/653c0a1d573b462a9663d7ed6b3970b6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

主要逻辑就是在**网关与聊天**服务上的`Receive回调方法`中实现的逻辑。

#### 网关Receive

网关中的Receive方法中接收到的是**SDK发过来的消息**。在通信协议一章上我们介绍过，web端的心跳使用的是`BasicPkt`基础协议，因此这里我们要判断读取到的packet类型，逻辑如下：
```go
// services/gateway/serv/handler.go

func (h *Handler) Receive(ag kim.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)
	packet, err := pkt.Read(buf)
	if err != nil {
		return
	}
        // 如果是BasicPkt，就处理心跳包。
	if basicPkt, ok := packet.(*pkt.BasicPkt); ok {
		if basicPkt.Code == pkt.CodePing {
			_ = ag.Push(pkt.Marshal(&pkt.BasicPkt{Code: pkt.CodePong}))
		}
		return
	}
        //如果是LogicPkt，就转发给逻辑服务处理。
	if logicPkt, ok := packet.(*pkt.LogicPkt); ok {
		logicPkt.ChannelId = ag.ID()

		err = container.Forward(logicPkt.ServiceName(), logicPkt)
		if err != nil {
			logger.WithFields(logger.Fields{
				"module": "handler",
				"id":     ag.ID(),
				"cmd":    logicPkt.Command,
				"dest":   logicPkt.Dest,
			}).Error(err)
		}
	}
}
```

如果是正常的业务逻辑LogicPkt包，就调用`container.Forward(logicPkt.ServiceName(), logicPkt)`发到后端服务中。在这里有一个**服务定位的逻辑**：

- 即`指令Command`与`逻辑服务`的关系。

```go
// wire/pkt/packet.go

func (h *Header) ServiceName() string {
	arr := strings.SplitN(h.Command, ".", 2)
	if len(arr) <= 1 {
		return "default"
	}
	return arr[0]
}
```

比如单聊协议`chat.user.talk`，前面的`chat`就是`ServiceName`，在容器container中就是根据这个`ServiceName`去获取对应的Client。

#### 逻辑服务Receive

我们接着上面的逻辑看，在Chat服务中，收到的消息也是通过`Receive`回调到了业务层。
```go
// services/server/serv/handler.go

func (h *ServHandler) Receive(ag kim.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)
        packet, err := pkt.MustReadLogicPkt(buf)
        if err != nil {
                return
        }
        var session *pkt.Session
        if packet.Command == wire.CommandLoginSignIn {
                server, _ := packet.GetMeta(wire.MetaDestServer)
                session = &pkt.Session{
                        ChannelId: packet.ChannelId,
                        GateId:    server.(string),
                        Tags:      []string{"AutoGenerated"},
                }
        } else {
                // TODO：优化点
                session, err = h.cache.Get(packet.ChannelId)
                if err == kim.ErrSessionNil {
                        _ = RespErr(ag, packet, pkt.Status_SessionNotFound)
                        return
                } else if err != nil {
                        _ = RespErr(ag, packet, pkt.Status_SystemException)
                        return
                }
        }
        logger.Debugf("recv a message from %s  %s", session, &packet.Header)
        err = h.r.Serve(packet, h.dispatcher, h.cache, session)
        if err != nil {
                log.Warn(err)
        }
}
```

其中`pkt.Session`是登录之后生成的，而`h.cache`则是`会话管理器`，在这里读者可以先忽略这部分与登录相关的内容。我们主要看链路中的**核心逻辑**：

- `h.r.Serve(packet, h.dispatcher, h.cache, session)`：消息被发向了`指令路由`。

接下来，我们看看`指令路由`是什么？

### 指令路由

指令路由与web服务中http的路由是类似的，一个最简单的版本包括如下几个部分：

- `type HandlerFunc func(Context)` - 处理器
- `type HandlersChain []HandlerFunc` - 处理链
- `type Context interface` - 处理器中的上下文
- `type Router struct` - 路由器

#### 上下文Context

Context的定义如下：
```go
// context.go

type Context interface {
	Dispatcher
	SessionStorage
	Header() *pkt.Header
	ReadBody(val proto.Message) error
	Session() Session
	RespWithError(status pkt.Status, err error) error
	Resp(status pkt.Status, body proto.Message) error
	Dispatch(body proto.Message, recvs ...*Location) error
}
```

主要方法有两个：

- Resp：回复消息，也就是给`发送方`返回一条消息。
- Dispatch：派发消息给指定的接收方`Location`。

其中Location表示一个用户的位置：`网关ID`和`ChannelId`，通过这两个信息就可以定位。
```go
// location.go

type Location struct {
	ChannelId string
	GateId    string
}
```

##### 消息Resp

**Resp**方法用于给消息发送方返回一条消息，所以`pkt.NewFrom`是通过复制`request.Header`生成一条新的消息包，然后修改了`Status`和`Flag`信息。
```go
// context.go

func (c *ContextImpl) Resp(status pkt.Status, body proto.Message) error {
	packet := pkt.NewFrom(&c.request.Header)
	packet.Status = status
	packet.WriteBody(body)
	packet.Flag = pkt.Flag_Response
	logger.Debugf("<-- Resp to %s command:%s  status: %v body: %s", c.Session().GetAccount(), &c.request.Header, status, body)

	err := c.Push(c.Session().GetGateId(), []string{c.Session().GetChannelId()}, packet)
	if err != nil {
		logger.Error(err)
	}
	return err
}
```

- c.Push是Dispatcher接口中的方法，这个Dispatcher是ContextImpl在Router中被创建时注入进来。

```go
// dispatcher.go

type Dispatcher interface {
	Push(gateway string, channels []string, p *pkt.LogicPkt) error
}
```

它的作用就是向网关**gateway**中的`channels`两个连接推送一条消息`LogicPkt`消息。这个`能力`是**容器提供的**，但是在这里为了**组件的职责划分更合理**，以及组件之间的解耦，**不会直接依赖container**。

##### 消息Dispatch

在逻辑服务中，消息的派发给网关需要考虑`单聊`和`群聊`两种情况。

- `单聊`情况下，如果不考虑`同账号多设备`，Dispatch时只会有一个接收方。
- `群聊`情况下，接收方的数量就是群中**所有在线的用户数**。

那么在群聊的Dispatch中，就有两个消息转发逻辑存在：

1. `分包转发`：每条消息都有自己的接收方，有几个接收方就会产生几条消息。

![dispatch.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2270a4a44b4ef9a5b94351117ee41a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

2. `合包转发`：把**相同网关**的所有接收方合并在一个包中发送到网关，**在网关中再拆分成多个包**。

![dispatch_combine.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccf306920c0b4b31b9548f8afd757cfe~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

独立转发的优点是逻辑简单，但是对带宽的浪费很大，所以不一般会采用，而是采用合并转发方式。如下：
```go
func (c *ContextImpl) Dispatch(body proto.Message, recvs ...*Location) error {
	if len(recvs) == 0 {
		return nil
	}
	packet := pkt.NewFrom(&c.request.Header)
	packet.Flag = pkt.Flag_Push
	packet.WriteBody(body)

	logger.Debugf("<-- Dispatch to %d users command:%s", len(recvs), &c.request.Header)

	// the receivers group by the destination of gateway
	group := make(map[string][]string)
	for _, recv := range recvs {
		if recv.ChannelId == c.Session().GetChannelId() {
			continue
		}
		if _, ok := group[recv.GateId]; !ok {
			group[recv.GateId] = make([]string, 0)
		}
		group[recv.GateId] = append(group[recv.GateId], recv.ChannelId)
	}
	for gateway, ids := range group {
		err := c.Push(gateway, ids, packet)
		if err != nil {
			logger.Error(err)
		}
		return err
	}
	return nil
}
```

在逻辑服务中的Dispather实现是这样的，**把多个channels数组合并成一个string，设置到消息包LogicPkt的Meta附加信息中**，再传输给网关。
```go
// services/server/serv/handler.go

type ServerDispather struct {
}

func (d *ServerDispather) Push(gateway string, channels []string, p *pkt.LogicPkt) error {
	p.AddStringMeta(wire.MetaDestChannels, strings.Join(channels, ","))
	return container.Push(gateway, p)
}
```

#### 路由器Router

首先，我们定义Router结构体
```go
// router.go
type Router struct {
	middlewares []HandlerFunc
	handlers    *FuncTree
	pool        sync.Pool
}
```

在Router中属性如下：

- `handlers`：注册的监听器列表。
- `pool`： 对象池。
- `middlewares`: 中间件

对象池的作用与线程池、连接池类似，都是通过重复利用提高性能，只不过对象池的作用是`减少内存的申请与回收`，使用方法如下：
```go
// router.go

// NewRouter NewRouter
func NewRouter() *Router {
	r := &Router{
		handlers:    NewTree(),
		middlewares: make([]HandlerFunc, 0),
	}
	r.pool.New = func() interface{} {
		return BuildContext()
	}
	return r
}

func BuildContext() Context {
	return &ContextImpl{}
}
```

- BuildContext就是创建一个空的Context实现对象。

我们主要来看下`Serve`方法：
```go
// router.go

func (s *Router) Serve(packet *pkt.LogicPkt, dispather Dispather, cache SessionStorage, session Session) error {
	if dispather == nil {
		return fmt.Errorf("dispather is nil")
	}
	if cache == nil {
		return fmt.Errorf("cache is nil")
	}
	ctx := s.pool.Get().(*ContextImpl)
	ctx.reset()
	ctx.request = packet
	ctx.Dispather = dispather
	ctx.SessionStorage = cache
	ctx.session = session

	s.serveContext(ctx)
        // 使用完之后放回池中
	s.pool.Put(ctx)
	return nil
}
```

在内部，首先就是从pool中取一个`ContextImpl`对象，然后就是注入

- **请求包**： pkt.LogicPkt
- **消息分发器**：Dispather
- **会话管理器**：SessionStorage
- **发送方会话**：Session

接下来就是调用serveContext处理这个ContextImpl：
```go
// router.go

func (s *Router) serveContext(ctx *ContextImpl) {
	chain, ok := s.handlers.Get(ctx.Header().Command)
	if !ok {
		ctx.handlers = []HandlerFunc{handleNoFound}
		ctx.Next()
		return
	}
	ctx.handlers = chain
	ctx.Next()
}
```

![消息调用链路.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05338453038f485d9f4109badb0ceea8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

这个逻辑就是根据Command找到处理链chain，然后就是ctx.Next()执行这个链了，这就是一个`责任链模式`，看下面的代码，在每个handler中执行ctx.Next()时就要调用到下一个处理器。
```go
// context.go

func (c *ContextImpl) Next() {
	if c.index >= len(c.handlers) {
		return
	}
	f := c.handlers[c.index]
	c.index++
	if f == nil {
		logger.Warn("arrived unknown HandlerFunc")
		return
	}
	f(c)
}
```

### 服务初始化

接下来，我们看看网关与逻辑服务的`启动逻辑`。

#### 网关

网关的启动顺序如下图：

![gateway_init.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/869e9e035d5c4a7c946fcc624a54f9d1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

```go
// services/gateway/server.go

func RunServerStart(ctx context.Context, opts *ServerStartOptions, version string) error {
	config, err := conf.Init(opts.config)
	if err != nil {
		return err
	}
	_ = logger.Init(logger.Settings{
		Level: "trace",
	})

	handler := &serv.Handler{
		ServiceID: config.ServiceID,
	}

	var srv kim.Server
	service := &naming.DefaultService{
		Id:       config.ServiceID,
		Name:     config.ServiceName,
		Address:  config.PublicAddress,
		Port:     config.PublicPort,
		Protocol: opts.protocol,
		Tags:     config.Tags,
	}
	if opts.protocol == "ws" {
		srv = websocket.NewServer(config.Listen, service)
	}

	srv.SetReadWait(time.Minute * 2)
	srv.SetAcceptor(handler)
	srv.SetMessageListener(handler)
	srv.SetStateListener(handler)

	_ = container.Init(srv, wire.SNChat, wire.SNLogin)

	ns, err := consul.NewNaming(config.ConsulURL)
	if err != nil {
		return err
	}
	container.SetServiceNaming(ns)

	// set a dialer
	container.SetDialer(serv.NewDialer(config.ServiceID))

	return container.Start()
}
```

#### 逻辑服务

逻辑服务的启动顺序如下图：

![server_init.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1261ff1f00d94d46b8f3960e4df9ecff~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

它比网关就多了`指令路由`与`会话管理器`两个模块。
```go
// services/server/server.go

func RunServerStart(ctx context.Context, opts *ServerStartOptions, version string) error {
	config, err := conf.Init(opts.config)
	if err != nil {
		return err
	}
	_ = logger.Init(logger.Settings{
		Level: "trace",
	})
        // 指令路由
	r := kim.NewRouter()
	// login
	loginHandler := handler.NewLoginHandler()
	r.Handle(wire.CommandLoginSignIn, loginHandler.DoSysLogin)
	r.Handle(wire.CommandLoginSignOut, loginHandler.DoSysLogout)

	rdb, err := conf.InitRedis(config.RedisAddrs, "")
	if err != nil {
		return err
	}
        // 会话管理
	cache := storage.NewRedisStorage(rdb)
	servhandler := serv.NewServHandler(r, cache)

	service := &naming.DefaultService{
		Id:       config.ServiceID,
		Name:     opts.serviceName,
		Address:  config.PublicAddress,
		Port:     config.PublicPort,
		Protocol: string(wire.ProtocolTCP),
		Tags:     config.Tags,
	}
	srv := tcp.NewServer(config.Listen, service)

	srv.SetReadWait(kim.DefaultReadWait)
	srv.SetAcceptor(servhandler)
	srv.SetMessageListener(servhandler)
	srv.SetStateListener(servhandler)

	if err := container.Init(srv); err != nil {
		return err
	}

	ns, err := consul.NewNaming(config.ConsulURL)
	if err != nil {
		return err
	}
	container.SetServiceNaming(ns)

	return container.Start()
}
```

### 总结

介绍完本章的内容，整个通信长连服务的`底层框架`就形成了**一个完整的闭环**，我们从`通信层`到容器层，再到`链路层`，现在就是**万事俱备，只欠东风**，而东风就下一章节的登录与退出。我们回顾一下重点知识：

- 消息派发逻辑：`分包`与`合包`。
- 对象池pool。
- 责任链模式。

**本章完！**