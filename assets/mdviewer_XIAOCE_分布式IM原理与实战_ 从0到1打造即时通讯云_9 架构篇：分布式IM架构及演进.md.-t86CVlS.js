import{_ as t}from"./app.BdTF1atn.js";import{j as o,i as e,Z as p}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/9 架构篇：分布式IM架构及演进.md","filePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/9 架构篇：分布式IM架构及演进.md"}'),d={name:"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/9 架构篇：分布式IM架构及演进.md"},c=p('<p>与web服务http短连接不同，即时通信由于客户端与服务之间要保持长连，而且既然叫即时通讯对消息的交付速度是非常高的，否则发条消息几秒之后送达就是个笑话了。因此本章我们聊聊IM系统的核心部分：<strong>分布式通信架构及它的演进过程</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bc36d9ed3e34f4b95691d13fee04987~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="chapter9.png"></p><h3 id="架构演进" tabindex="-1">架构演进 ​</h3><h4 id="一、单体架构" tabindex="-1">一、单体架构 ​</h4><p>在Web服务中，HTTP/1.x是一个无状态的协议，这里的<strong>状态</strong>指的就是每次请求都是<strong>独立</strong>的，请求之间没有关联，它与HTTP KeepAlive 连接复用无关。也就是在<strong>HTTP协议</strong>中你找不出一个<code>唯一标识</code> 来表示多次不同的请求之间是有联系的。早期的 Web 系统，只能在上层使用 Cookie 加 Session 技术，即客户端每次请求会带上 SessionID，服务端也会记录下 SessionID 与用户的关系，因此导致服务变成了<code>有状态</code>，这也导致它很难扩展。</p><p>而在即时通信这类长连接的系统中，客户端与服务端建立了连接之后，除非主动退出否则<strong>不会主动断开连接</strong>，服务端则会维护<strong>用户与TCP连接</strong>的关系，既<code>连接就是用户</code>，如此就可以实现服务端主动推送消息给指定的用户，实现即时聊天之类的功能。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3cca41b1cf84b8aaaf5f2e47e9a1421~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure1.png"></p><p>如图是一个最简单的单体通信架构图，它的功能包括了<code>连接管理</code>、<code>会话管理</code>、<code>消息处理</code>等基本逻辑。用户登录的会话会保存到内存中，<code>我们在后面一个Demo 章节会演示它的大致逻辑</code>，它读写逻辑简单，由于会话都在同一个进程内部，消息的转发效率非常高，只要在 Coding 时处理好<code>并发锁</code>之类的技术性问题，转发吞吐量是非常高的。它的优点是就是架构简单，开发相对容易，可以应对要求不高的场景。</p><p><strong>但它主要有如下缺陷：</strong></p><ol><li>单机的并发连接是有上限的，无法扩展。</li><li>单点故障会导致系统不可用。</li></ol><p>当然，不是说服务宕机，客户端连接就断开了，生命周期结束，消息就无法收发了。客户端通常都有<code>异常断线自动重连机制</code>，如果服务器能够立刻完成重启，客户端也会重新连接进来。同时，也可以使用<code>vip</code>（虚拟 ip ）技术做一个主从的架构，当主节点宕机，ip 会飘到备用的节点上去，客户端重连机制会重新与服务端建立连接。当然，无论是哪种情况，系统的 SLA 指标都不会太高，因为在这个恢复的过程中，多少会对用户造成影响。</p><h4 id="二、集群架构" tabindex="-1">二、集群架构 ​</h4><p>那么，有状态单体架构的扩展问题该如何解决呢？做过 Web 系统的人，通常第一反应就是把通信服务扩容到多台，如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f46e08eefd474eabba9651ac7c5b33d2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure1.2.png"></p><p><strong>如此一来，扩展是可以扩展了，但也面临两个问题：</strong></p><ol><li>用户 A 要发消息给用户 C，在<strong>通信服务 S1</strong> 中该如何找到用户 C 所在的 S2?</li><li>知道了用户 C 所在的通信服务 S2，如何把消息转发过去?</li></ol><h4 id="mq-架构" tabindex="-1">MQ 架构 ​</h4><p>有些经验的读者，可能马上想到了开发 Web 系统的两大利器：<code>缓存与消息中间件</code>。因为在web服务中，通常使用缓存如redis来存储登录会话，使服务变为<strong>无状态</strong>，达到水平扩展的目的。而消息中间件MQ则可用于跨进程异步通信，通常用于多个系统之间解耦。于是架构就变成了这样：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/005e91f74f2f42a1bb580252263c72d2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure1.1.png"></p><p>通过把<code>用户与通信服务的关系</code>记录到 Redis 缓存中，可以解决第一个问题；通过消息中间件，可以解决服务之间的通信的问题。于是，扩展问题就得到完美解决了~</p><blockquote><p>那么，这样做的优缺点是什么呢？我们先不给答案，读者可以看过之后的内容针对MQ的特点自己思考。</p></blockquote><h4 id="分层架构" tabindex="-1">分层架构 ​</h4><p>在微服务体系中，通常都会有<code>网关</code>层，它的作用如下：</p><ul><li>服务聚合</li><li>鉴权</li><li>限流</li><li>路由</li><li>负载均衡</li></ul><p>通过把鉴权、限流之类的通用逻辑分离到网关中，后端服务就只需要关注业务逻辑的实现，而且服务之间就可以直接调用而无需经过鉴权逻辑，总之优点还是很多的，当然缺点就是增加整个系统的复杂度。同样，在即时通信架构中也可以引用网关层，来解决<code>单体架构</code>中的扩展问题，整个架构就变成了下面的样子：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35fb984f80974834a0229afd3eb99ef4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure2.png"></p><p>通过分层，网关与逻辑服务的职责就更加清晰：</p><ol><li><p>接入网关：</p><ul><li>维护与用户的长连接。</li><li>转发消息到逻辑服务。</li></ul></li><li><p>逻辑服务：</p><ul><li>维护登录会话。</li><li>处理网关转发来的消息。</li></ul></li></ol><p><strong>如此一来，消息的链路就发生了改变：</strong></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23fbddec100b41d3996ae95d9b88893d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="msg_road.png"></p><p>用户发送到网关的消息，会被转发到逻辑服务器，在逻辑服务器中找到<strong>接收方</strong>登录所在网关，由于<strong>所有网关</strong>都与逻辑服务器之间建立了<strong>长连接</strong>，因此逻辑服务可以主动把消息Push给接收方所在的网关，再由此网关把消息转发给用户B。</p><p>因此逻辑服务器就变为了一个<code>有状态</code>的服务，因为它维护了<code>用户</code>与<code>网关</code>的关系：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4401f84b69f74f3daed064920233ae6e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="msg_route.png"></p><p>我们来对比下三个方案优缺点：</p><table tabindex="0"><thead><tr><th>指标</th><th>单体架构</th><th>MQ版架构</th><th>分层架构</th></tr></thead><tbody><tr><td>开发难度</td><td><code>+</code></td><td>++</td><td>+++</td></tr><tr><td>消息处理时长</td><td><code>+</code></td><td>++++</td><td>++</td></tr><tr><td>扩展性</td><td>+</td><td>++</td><td>+++</td></tr><tr><td>逻辑耦合度</td><td>++++</td><td>+++</td><td><code>++</code></td></tr><tr><td>故障时恢复时间</td><td>++++</td><td>+++</td><td><code>++</code></td></tr></tbody></table><p>可以看到，单体架构开发难度与消息转发能力是最优的，但是其它方面就不行了，MQ架构处于中等水平，分层架构更灵活。不过以上评测只是根据它的架构特点和实际经验给出的一个参考数据，读者可以看完本小册的内容理解了细节之后，再来反思每种架构的特点。</p><h4 id="三、分布式架构" tabindex="-1">三、分布式架构 ​</h4><p>由于分层架构的扩展性好，逻辑耦合度不高等特点，因此我们考虑在分层架构的基础上来升级架构。</p><p><strong>那么我们首先要解决逻辑服务器扩展问题，通常可以采用如下两种方案：</strong></p><ul><li><strong>方案一</strong>在网关层通过<strong>用户标签</strong>来做路由，保证相同标签的用户永远登录到相同的逻辑服务，比如多租户中App1的用户登录到逻辑服务A，App2的用户登录到逻辑服务B，由于App1与App2的用户不会互相通信，<strong>每台逻辑服务中都保存了一个App完整的会话信息</strong>，因此同一个App用户之间的消息收发，始终经过同一个逻辑服务，不会存在找不到会话的问题。</li><li><strong>方案二</strong>把会话信息从逻辑服务中分离出去，保存到<strong>高性能的缓存中间件</strong>（如Redis）中，这样所有的逻辑服务器都通过这个缓存来读写会话信息，变为一个<code>无状态</code>的服务，就没有扩展及单点问题了。</li></ul><p><strong>两种方案各有利弊：</strong></p><ul><li><code>方案一</code>优点是会话保存在内存中<strong>读取性能最高</strong>，但是也会导致会话在不同逻辑服务器存储的不平衡，<strong>而且逻辑服务重启或转移会导致客户端重新连接建立会话</strong>。</li><li><code>方案二</code>由于会话被分离到进程之外，会话读写性能下降很多，消息的转发吞吐量会下降。优点就是更加灵活、简单及扩展性好。</li></ul><p><strong>在本小册中我们采用方案二来设计通信架构</strong>，如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167fee31eb7a46439f6216207d01392d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure3.png"></p><p>对比前一个架构方案，这里主要优化了两点：</p><ol><li><strong>会话分离</strong></li></ol><p><strong>登录会话写缓存Redis</strong>，通过增加一个会话存储服务，最明显的好处就是逻辑服务器变为了<code>无状态</code>，可以随时扩容。但是<code>会话存储</code>与<code>逻辑服务</code>分离的后果，就是消息转发<strong>性能下降</strong>，特别是群消息转发。比如一个群成员有500人，一次消息转发就需要访问500次缓存，转发100条群消息，就需要访问50W+次缓存，不过优化的方法还是有很多的，我们在后面章节再介绍。</p><ol start="2"><li><strong>逻辑拆分</strong></li></ol><p>会话分离的另一个好处就是可以实现逻辑服务的<strong>垂直拆分</strong>，这与web系统中的<strong>微服务</strong>原理类似。通过拆分就可以实现<code>业务隔离</code>。不过由于IM系统我们是从底层到上层都是自己实现，因此有两个要点：</p><ul><li>就是在网关层具有<code>服务聚合</code>的能力，与前面提到的微服务中的逻辑类似。</li><li>逻辑服务内部设计时组件分层要合理，否则会有大量重复代码，这对编码能力及抽象能力有较高要求的。</li></ul><blockquote><p>我们在逻辑上支持多个服务的拆分，但是在部署时，可以根据实际情况，混合部署，比如多个服务都在同一个进程内。</p></blockquote><h3 id="最后总结" tabindex="-1">最后总结 ​</h3><p>本章一次讲了通信系统的多个架构方案及演变，但是本质上都是在<code>可扩展</code>、<code>高性能</code>与<code>高可用</code>这三个因素之间做出一定的取舍，这与分布式系统的CAP理论是有相同之处的。而且相信读者也看出来了，通信系统的架构是非常灵活多变的，同样是通信系统，在直播场景就不会使用这个方案。</p><p><strong>本章完！</strong></p>',54),r=[c];function i(s,n,l,g,a,b){return e(),o("div",null,r)}const j=t(d,[["render",i]]);export{h as __pageData,j as default};
