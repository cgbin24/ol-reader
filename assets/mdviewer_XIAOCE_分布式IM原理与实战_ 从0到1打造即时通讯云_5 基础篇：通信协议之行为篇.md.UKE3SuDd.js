import{_ as t}from"./app.BdTF1atn.js";import{j as s,i,Z as a}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/5 基础篇：通信协议之行为篇.md","filePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/5 基础篇：通信协议之行为篇.md"}'),e={name:"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/5 基础篇：通信协议之行为篇.md"},p=a(`<p>在上一篇，我们从<code>状态</code>这个角度来介绍了网络协议基本情况及特点。而本篇核心就是<code>行为</code>，我们来看看消息是如何从我们的应用程序中<strong>通过网络发送到世界上另台主机上的</strong>，以及协议的每层发生了什么？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887e6f2f6e4c496e9309ec4728acadb2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="chapter5.png"></p><h3 id="socket简介" tabindex="-1">Socket简介 ​</h3><p>在开始介绍分层协议的逻辑之前。读者需要明白，我们在应用程序（比如demo示例）中，无论是使用websocket还是tcp协议，都是通过socket来编码。</p><blockquote><p>那么socket什么，它是协议吗？</p></blockquote><p>首先，Socket（套接字）<strong>不是协议</strong>，它是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。<strong>如下是Socket全部接口</strong>：</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Create()</td><td>创建socket</td></tr><tr><td>Bind()</td><td>绑定地址</td></tr><tr><td>Listen()</td><td>准备接收连接</td></tr><tr><td>Connect()</td><td>客户端建立连接</td></tr><tr><td>Accept()</td><td>服务端接受连接</td></tr><tr><td>Write()</td><td>发送数据</td></tr><tr><td>Read()</td><td>接收数据</td></tr><tr><td>Close()</td><td>关闭连接</td></tr></tbody></table><p>其次，Socket抽象出了两个核心概念就是<strong>客户端</strong>与<strong>服务端</strong>，它们的逻辑不一样，主要是因为server端有一个特殊的socket，通过监听客户端的握手包，成功之后就会创建一个新的socket（比如demo示例中UpgradeHTTP之后的conn对象），但是在TCP协议中是没有这两个概念哈，只要两个站点在<strong>网络层</strong>是<strong>双向互通</strong>（比如都有公网IP），任意一方都可以发起与对方建立连接；另外在Socket编程逻辑中，TCP建立连接的<strong>三次握手的阶段</strong>，是不发送<code>消息体</code>的，<strong>但是在TCP协议上也没有规定握手阶段不允许发送消息载体的</strong>，这就导致我们通常情况下要在连接建立之后，再次发送一个消息包来做业务层的权限之类的认证，而不是在握手时。</p><p>最后，通常我们所说<strong>网络通信</strong>，就是使用如下两种类型的Socket:</p><ol><li>Stream Socket：基于TCP/IP协议<code>面向连接</code>的流式传输套接字，特点是安全，可靠。</li><li>Datagram Socket：基于UDP/IP协议的<code>面向消息</code>的套接字，特点是不保持可靠性，简单，速度快。</li></ol><p>当然，在本小册中我们是使用tcp而不是udp通信，因此下面我们来了解下tcp与udp最大的一个区别：<strong>面向连接</strong>。</p><h3 id="应用层行为" tabindex="-1">应用层行为 ​</h3><p>TCP是<code>全双工</code>通信协议，建立一条连接时，操作系统就需要为它在<code>内核内存</code>中分配<code>两个缓冲</code>区（读buffer,写buffer），大小由系统参数决定。但是我们的应用程序是在<code>用户态</code>，用户态进程是无法直接访问<code>内核内存</code>空间的。因此通过Socket接口我们Write数据到底层的过程中，就要涉及一次数据的<code>拷贝</code>，也就是把数据从进程内存中拷贝到tcp写缓冲，这就是一次IO操作。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5952fb533bb54e4fb88cc8a9cace6004~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="用户态及内核态.png"></p><p>服务端的C10K问题说的就是这里。在通信系统中，由于服务端一个进程需要同时监控大量的Socket（客户端）中的数据；早期我们在应用程序中每创建一个Socket就创建一个<strong>核心线程</strong>，在这个线程中循环读取Socket中是否有数据，相信大多数JAVA程序员都有印象，<strong>这就是BIO同步阻塞模型</strong>；包括后来的Select、Poll之类的多路IO复用，也就是一个线程就可以监控多个Socket，但是由于它们逻辑上对CPU的开销都非常大，都导致服务端进程维护10K连接很难。直到后来出现了<code>Epoll</code>等事件驱动模型的多路IO复用的出现，才从根本上解决了这个问题，当然，本章就不深入介绍epoll的原理了。</p><p>我们简单看看Linux中TCP缓冲区大小，这关系到单机<code>连接数与内存占用</code>的关系！</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sys/net/ipv4/tcp_rmem</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">4096</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	87380</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">	6291456</span></span></code></pre></div><p>结果显示的分别是:</p><ol><li><code>最小值</code>: 给socket接收缓冲区分配的最小值4K</li><li><code>默认值</code>: 接收缓冲区大小在系统负载不重的情况下可以增长到这个值</li><li><code>最大值</code>: 接收缓冲区最大值</li></ol><blockquote><p>读者get到<code>面向连接</code>与<code>面向消息</code>的区别了吗？</p></blockquote><p><strong>接下我们就看看第4层传输层的逻辑：</strong></p><h3 id="传输层行为" tabindex="-1">传输层行为 ​</h3><blockquote><p>你以为理解了tcp协议的逻辑就完了吗？</p></blockquote><p>在现实网络中，由于IPv4地址数量限制无法给每台主机分配一个独立IP，于是才有了NAT（Network address translation）网关。比如我们家中的出口路由器，拨号上网时由运营商ISP分配一个临时公网IP。TCP/IP数据包在发送到NAT网关上时，网关至少有两次拆包才能得到：IP协议头、TCP协议头（它们处于不同的协议层）。然后修改数据包中的<code>源IP</code>及<code>源端口</code>和<code>校验信息</code>，IP会替换成NAT网关的出口IP，端口就需要动态分配。并把这个信息记录到<code>转换表</code>，这样当NAT收到回复消息时，通过消息中的<strong>目的地端口</strong>可以反查<code>转换表</code>可以得到接收方的内网ip地址。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08df26eea235411789c4910b7477ed56~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="NAT.png"></p><blockquote><p>通常我们所说的NAT<code>打洞</code>，就是一台内部主机利用一台公网服务器在NAT网关中添加一条转换记录，另一个主机就可以通过NAT转换记录中的端口与内部主机建立点对点的接连。但是有些NAT网关会记录并验证接收数据包中的来源IP与端口，这样打洞就失败了。</p></blockquote><p>由于NAT的转换表中的记录是有一个<code>老化时间</code>的，如果连接空闲时间超过这个值，记录就被清掉，此时外部来的消息就无关送到到NAT内部的主机，连接也就断开了。</p><p><strong>时光倒流，TCP缓存中的数据在操作系统中需要知道发送到那个网卡（看图一主机与路由器都 是支持IP协议的，只不过主机通常只有一到两个对外网卡），接下来的逻辑就发生在网络层</strong>。</p><h3 id="网络层行为" tabindex="-1">网络层行为 ​</h3><p>在一个IP网络中，路由（Routing）是个非常基本的概念。网络的基本功能，是使得处于网络中的两个IP节点能够互相通信，而通信实际上就是数据交互的过程，数据交互则需要网络设备帮助我们将数据在两个通信节点之间进行传输，路由器就是其中非常重要的一个网络设备。</p><p>当路由器（或者其他三层设备）收到一个IP数据包，路由器<strong>拆包</strong>得到IP报文头中的<code>目的IP地址</code>，然后拿着目的IP地址到自己的<code>路由表</code>（Routing Table）中进行查找，找到“最匹配”的路由条目后，将数据包根据路由条目所指示的出接口或下一跳IP转发出去，这就是路由。</p><p><strong>在一台linux主机中输入route可以看到如下路由表：</strong></p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># route -n</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Kernel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> IP</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> routing</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> table</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Destination</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     Gateway</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         Genmask</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         Flags</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Metric</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Ref</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Use</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Iface</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0.0.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         172.19.63.253</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   0.0.0.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         UG</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    100</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">172.17.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0.0.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         255.255.0.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     U</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">172.18.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0.0.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         255.255.0.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     U</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker_gwbridge</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">172.19.48.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0.0.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         255.255.240.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   U</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">172.19.63.253</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   0.0.0.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">         255.255.255.255</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> UH</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    100</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> eth0</span></span></code></pre></div><p><strong>主要参数如下：</strong></p><table tabindex="0"><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>destination</td><td>目的网段；（0.0.0.0或default）表示通向默认网关。如果没有找到路由记录就走此网关</td></tr><tr><td>Gateway</td><td>网关地址；（0.0.0.0）表示当前记录对应的目的网段跟本机在同一个网段，通信时不需要经过网关</td></tr><tr><td>Genmask</td><td>子网掩码；<code>目标IP</code>和子网掩码做<code>逻辑与</code>计算可以得出<code>目的网段</code></td></tr><tr><td>Flags</td><td>标记；U 路由是活动的、H 目标是个主机、G 需要经过网关</td></tr><tr><td>Metric</td><td>跳数;当有多个匹配的记录时，选择跳数最小的记录</td></tr><tr><td>Iface</td><td>网卡；例如 eth0</td></tr></tbody></table><p><strong>我们说人话就是</strong>：如果<strong>目的IP地址</strong> <strong>逻辑与</strong> <strong>子网掩码</strong>（Genmask）等于<strong>目的网段</strong>(Destination)，就把这条消息发送到<strong>此条目</strong>指定的<strong>网卡</strong>（Iface）上。如果找到多个条目，取其中<strong>跳数</strong>（Metric）最小条目。</p><p>一个<strong>简化</strong>的数据包路由图如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047e81971a4449738da4fbe46e37f117~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="ip路由.png"></p><p>在图中有5个路由器，两个主机，它们都有自己的路由表。在广域网中，一个路由器通常会连接到两个以上不同的<code>子网</code>，比如数据包从A发往B的过程中，经过的R3路由器。如果修改R3的路由配置，线路就可能变为A -&gt;R1 -&gt;R3（杭州）-&gt;R4（北京）-&gt;R5（上海）-&gt;B（上海），如此一来路径就会变长，按来回的里程估计2000KM算，Ping的延迟会增加80ms左右。</p><p><strong>再次时光倒流，我们回到局域网内部，往协议的更底层进一步，就是链路层行为。</strong></p><h3 id="链路层行为" tabindex="-1">链路层行为 ​</h3><p>数据从网络层走向链路层的过程中，需要说明的是网络地址(IP)与链路层地址(MAC)是不同部门分配的，MAC地址是硬件（比如第一章提到的网卡）制造时决定的，IP地址由网络管理员分配。在链路层<code>设备</code>通信只设别MAC地址，所以这里就涉及一次<strong>IP地址解析</strong>的过程。</p><h4 id="arp" tabindex="-1">ARP ​</h4><p>ARP（Address Resolution Protocol）即<code>地址解析协议</code>， 用于实现从IP地址到MAC地址的映射，即询问目标IP对应的MAC地址。大致过程就是主机向链路层网段上所有主机（<strong>广播地址</strong>）发一个ARP请求的以太网帧，它包含了目的主机的IPv4地址（192.168.3.213），意思就是&quot;如果你的Ip地址是192.168.3.213，请向我回应你的MAC地址&quot;。主机在收到响应消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p><strong>使用tcpdump监听的一条ARP数据包：</strong></p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">13:03:50.791235</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ARP,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Request</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> who-has</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 192.168.3.213</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tell</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.3.1,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> length</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 46</span></span></code></pre></div><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存。<strong>ARP协议也是因此非常不安全</strong>。</p><h4 id="直接交付" tabindex="-1">直接交付 ​</h4><p><code>直接交付</code>因为没有跨网段不需要经过路由器，IP数据报封装在一个链路层帧中，它可以直接识别数据来源或目的。</p><p>在星型拓扑结构中，我们的主机或者服务器<strong>至少有一个网口</strong>通过与路由器或者交接机的某个网口连接在一起；其中网线连接的是LAN(Local Area Network本地网口)，无线连接的是WLAN网口。而路由器或者交接机都是有多个LAN口，还会有一个WAN口（Wide Area Network广域网）接入互联网。交换机只有LAN口，路由器的多个LAN口也可以当作交换机使用。因此，在以太网中MAC地址的通信就是要<code>选择一个正确的LAN口</code>，把数据帧通过这个LAN转换成电信号的发送过去。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9662d3533a4d4a84a17ddd175b985279~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="write_copy.png"></p><p>上图是一个包括两台交换机的扩展以太网例子。每个交换机及站点都有自己的MAC地址，交换机的端口都有编号。其中两台主机连接交换机A，两台服务器连接交换机B。比如macbook<code>82:b6:af:a5:0c:00</code>要给主机<code>82:b6:af:a5:0c:01</code>发消息，首先数据会到达交换机A，这时交换机A还不知道<code>82:b6:af:a5:0c:01</code>所在的端口，它会把消息交付给2、3端口（<strong>这会导致不必要的开销</strong>），同时记下端口1的MAC地址，这就是一次学习过程，如果主机<code>82:b6:af:a5:0c:01</code>要回复消息，到达交换机A之后，交换机A因为之前已经记录下来了端口1接入的MAC地址，它就会直接把消息交付到端口1，下图是交换机A经过学习之后的数据库。</p><table tabindex="0"><thead><tr><th>站</th><th>端口</th></tr></thead><tbody><tr><td>82:b6:af:a5:0c:00</td><td>1</td></tr><tr><td>82:b6:af:a5:0c:01</td><td>2</td></tr><tr><td>3e:22:fb:25:2f:18</td><td></td></tr><tr><td>3c:22:fb:25:2f:19</td><td>3</td></tr><tr><td>86:2c:d3:7f:57:31</td><td>3</td></tr><tr><td>ac:2e:48:00:11:22</td><td>3</td></tr></tbody></table><p><strong>我们把视角拉高，再来看看消息在整个网络传输的过程交付逻辑。</strong></p><h4 id="间接交付" tabindex="-1">间接交付 ​</h4><p><code>间接交付</code>涉及路由器，数据转发到这台路由器，并使用该路由器的链路层地址作为目的地址。我们把上面路由表中的图从另一个角度表达就是这样子：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d1eb4b645884316b1df77ccce6b222f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="eth_dilivery.png"></p><p>可以看到，在IP网络层数据包是没有变化的，但是在每一个节点，都需要做一次<code>路由</code>，同时链路层数据帧协议头中的<code>源地址</code>和<code>目标地址</code>都会发生变化。</p><h3 id="最后总结" tabindex="-1">最后总结 ​</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d77f4d5d18894618a881cdc66f211573~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="5layer_flow.png"></p><p>通信协议两个章节的介绍，实际上就是为了解读上面这张图。通过这两章的理解，当我们回头再来看这张图，我相信读者多少会有些收获，<strong>理解了这张图你就基本上理解了网络协议的核心知识点</strong>。不过由于篇幅有限，无法讲太多细节，如果读者还想更深入的了解，可以阅读tcp/ip协议卷一书。</p><p><strong>本章完！</strong></p>`,62),n=[p];function d(o,h,k,r,l,c){return i(),s("div",null,n)}const B=t(e,[["render",d]]);export{y as __pageData,B as default};
