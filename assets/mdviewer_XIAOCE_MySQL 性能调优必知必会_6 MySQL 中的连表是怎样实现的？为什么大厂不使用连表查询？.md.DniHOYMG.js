import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as e,Z as a}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/MySQL 性能调优必知必会/6 MySQL 中的连表是怎样实现的？为什么大厂不使用连表查询？.md","filePath":"mdviewer/XIAOCE/MySQL 性能调优必知必会/6 MySQL 中的连表是怎样实现的？为什么大厂不使用连表查询？.md"}'),n={name:"mdviewer/XIAOCE/MySQL 性能调优必知必会/6 MySQL 中的连表是怎样实现的？为什么大厂不使用连表查询？.md"},t=a(`<p>通常，我们使用数据库的时候，需要两个或多个表互联才能得到我们想要的结果。但是，当数据库的数据到达一定的规模之后，<code>DBA</code>通常会建议我们不要使用 <code>join</code> 或者不建议三个表以上使用 <code>join</code>。</p><p>这是为什么呢？今天我们就来聊聊这个话题。</p><p>如果我们要来讨论为什么不建议使用<code>join</code>，首先我们需要一起了解一下<code>join</code>的底层原理。说起<code>join</code>的底层，我们就不得不介绍实现它的三个算法，分别是：<code>Index Nested-Loop Join</code>、<code>Simple Nested-Loop Join</code>和<code>Block Nested-Loop Join</code>。</p><p>为了方便测试，我创建如下数据表：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 创建数据表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_joinv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> PRIMARY KEY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AUTO_INCREMENT,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    m </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    KEY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`index_1\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`m\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)ENGINE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InnoDB AUTO_INCREMENT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CHARSET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">utf8;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 复制test_joinv2数据表</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test_joinv2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> LIKE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 通过存储过程造部分数据给 test_joinv2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">drop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> procedure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> create_data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">delimiter ;;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> procedure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> create_data()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">begin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    declare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)do </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        insert into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, i, i); </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    end</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">delimiter ;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> create_data();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 复制部分 test_joinv1 的数据给 test_joinv2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv2 (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="index-nested-loop-join" tabindex="-1">Index Nested-Loop Join ​</h3><p><code>Index Nested-Loop Join</code> 翻译过来的意思是：索引循环嵌套链接，简称 <code>INLJ</code>。它是基于索引的链接算法。我们采用如下 SQL 进行解释：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">STRAIGHT_JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">test_joinv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> test_joinv2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>注意：这里不使用<code>join</code>的原因是<code>join</code>已经经过优化了，会自动选择最优的驱动表，这里选择使用<code>STRAIGHT_JOIN</code>的原因是它既跟<code>join</code>的功能相同，同时只会选择它左边的表作为驱动表。</p><p>我们通过<code>explain</code>可以查看到数据表<code>test_joinv2</code>（被驱动表）上有一个索引被命中。具体如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6248156111241289673c6b1ebc72920~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>这种状态下该条 SQL 的执行流程如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09cb09bab6864ea69fe04d18a8f165eb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><ul><li>第一步：会在 <code>test_joinv1</code> 数据表中获取一条数据。</li><li>第二步：通过第一步中获取的 <code>m</code> 数据去 <code>test_joinv2</code> 数据表中进行匹配。</li><li>第三步：将 <code>test_joinv2</code> 数据表中匹配到的数据与 <code>test_joinv1</code> 获取的数据合并，并重复前三步。</li><li>第四步：匹配完所有的结果之后，返回所有符合要求的数据。</li></ul><p>在这个连表查询的过程中，首先会扫描 <code>test_joinv1</code> 数据表，总共需要读取 <code>10000</code> 行。当在第三步中拿第二步中获取的数据 <code>m</code> 到 <code>test_joinv2</code> 数据表中进行查询判断，但是由上图可知该条 SQL 命中了 <code>test_joinv2</code> 中 <code>m</code> 字段上的索引，所以根据索引的特性在数据表 <code>test_joinv2</code> 中按照树形算法查询相匹配的数据，所以查询的结果是 <code>1000</code> 行。由此可知，上述的 SQL 在使用 <code>join</code> 连表查询的结果是 <code>10000 + 1000 = 11000</code> 次。</p><p>在使用 <code>INLJ</code> 时候我们还有一种情况，就是使用 <code>test_joinv2</code> 作为驱动表时，情况会如何呢？具体如下：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">STRAIGHT_JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">test_joinv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> test_joinv2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>这时我们通过 <code>explain</code> 可以查看到数据表<code>test_joinv1</code>（被驱动表）上有一个索引被命中。具体如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0acbcf936a0458fba5e9f1c95e92ad1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>这时查询的步骤具体分析如下：</p><ul><li>第一步：首先会在 <code>test_joinv2</code> 数据表中获取一条数据。</li><li>第二步：通过第一步中获取的 <code>m</code> 数据去 <code>test_joinv1</code> 数据表中进行匹配。</li><li>第三步：将 <code>test_joinv1</code> 数据表中匹配到的数据与 <code>test_joinv2</code> 获取的数据合并，并重复前三步。</li><li>第四步：匹配完所有的结果之后，返回所有符合要求的数据。</li></ul><p>由此，我们可以得出，首先会扫描 <code>test_joinv2</code> 中的所有数据，也就是 <code>1000</code> 条；但是因为命中了 <code>test_joinv1</code> 数据表中的索引，所以在数据表 <code>test_joinv1</code> 中只需要查询 <code>1000</code> 条数据，最终的结果总共查询出 <code>1000 + 1000 = 2000</code>次。</p><p>通过对比，我们可以得出：<strong>当需要基于索引连表查询时，我们采用较为小的数据表（业内称之为：小表）作为驱动表，有利于提高查询的效率</strong>。</p><p>这里我们再来分析一下在不使用连表的情况下，数据库查询的流程。按照我们写代码的逻辑，首先会在 <code>test_joinv1</code> 数据表中查询所有的数据，也就是 <code>10000</code> 行；然后再去数据表 <code>test_joinv2</code> 中匹配查询，最终在 <code>testjoinv2</code> 表中查询的数据也是 <code>1000</code> 行。于是我们可以得出查询在分开查询的情况下，查询的次数依然是 <code>10000 + 1000 = 11000</code> 次。</p><p>于是我们可以得出：<strong>在使用索引的情况下，<code>join</code> 连表查询要比拆分开来的方式的性能要好</strong>。</p><p>下面，我们再来讨论一下在不使用索引的情况下，连表查询的性能又该是如何？</p><h3 id="simple-nested-loop-join" tabindex="-1">Simple Nested-Loop Join ​</h3><p><code>Simple Nested-Loop Join</code> 翻译过来的意思是：简单嵌套循环链接，简称 <code>SNLJ</code>。这个算法没有做任何优化，每一次查询都会扫描链接的所有表，性能低下。我们采用如下的 SQL 来进行解释：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">STRAIGHT_JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test_joinv2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">test_joinv1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> test_joinv2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>简单嵌套循环链接其实就是简单粗暴地进行链接查询，具体分析如下。</p><p>首先，该条 <code>SQL</code> 会直接扫描数据表 <code>test_joinv1</code> ，也就是说会查询 <code>10000</code> 次，然后拿在 <code>test_joinv1</code> 中查询出来的的数据全表扫描数据表 <code>test_joinv2</code>，最终查询的总次数为 <code>10000 * 1000 = 1千万次</code>。</p><p>所以，在使用 <code>SNLJ</code> 时，MySQL 数据库连表查询的性能是极差的。我不建议你使用，并且 MySQL 数据库也没有使用这种算法。</p><p>那么，在没有使用索引的情况下，MySQL 的连表查询情况到底该是如何呢？我们一起往下看。</p><h3 id="block-nested-loop-join" tabindex="-1">Block Nested-Loop Join ​</h3><p><code>Block Nested-Loop Join</code> 翻译过来的意思是：缓存块嵌套循环链接，简称 <code>BNLJ</code>。这种算法是使用缓存块将所有的数据在内存中进行比较（主要是内存的速度非常快），其核心是利用内存的空间换取时间。具体分析如下。</p><p>我们仍然借助于上述 <code>SNLJ</code> 的 <code>SQL</code> 来分析。通过 <code>explain</code> 来查看这条 SQL 的具体情况：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c95269edee42cd8cca6533025cb492~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>我们可以看到 <code>Extra</code> 字段中有 <code>Using join buffer (Block Nested Loop)</code> ，也就说明该<code>SQL</code>将使用 <code>BNLJ</code>，下面我们来详细分析一下这个过程中经历的内容。</p><p>首先，我们来一起看一下该条 <code>SQL</code> 执行的过程。</p><ul><li>第一步：首先会将数据表 <code>test_joinv1</code> 中的数据查询出来，存放在 <code>join_buffer</code> 之中。</li><li>第二步：将数据表 <code>test_joinv2</code> 中的数据查询出来，与 <code>join_buffer</code> 中的数据，按照 <code>test_joinv1.m = test_joinv2.n</code> 进行对比（对比的过程发生在内存之中）。</li><li>第三步：将符合条件的数据组装并返回。</li></ul><p>由此，我们可以得出的是：</p><ul><li>第一条：该过程需要扫描 <code>test_joinv1</code> 数据表 <code>10000</code> 行；扫描 <code>test_joinv2</code> 数据表 <code>1000</code> 行。</li><li>第二条：通过条件 <code>test_joinv1.m = test_joinv2.n</code> 需要在 <code>join_buffer</code> 中判断 <code>10000 * 1000 = 1千万次</code></li></ul><p>这个时候不免有些朋友会想，如果 <code>join_buffer</code> 的空间不足以承载数据表 <code>test_joinv1</code> 中查询出来的所有的数据怎么办呢？</p><p>下面我们就来分析这一过程：</p><ul><li>第一步：扫描数据表 <code>test_joinv1</code> 中的数据，直至 <code>join_buffer</code> 没有剩余空间，进行下一步。</li><li>第二步：扫描数据表 <code>test_joinv2</code> 中的数据，将取出来的数据与 <code>join_buffer</code> 中保存的数据进行比较，然后将符合条件的数据进行封装、返回。</li><li>第三步：清空 <code>join_buffer</code> 中的所有内容，然后重复第一步和第二步，直至完成所有。</li></ul><p>注意：MySQL 数据库中控制 <code>join_buffer</code> 空间大小的参数是 <code>join_buffer_size</code>。</p><p>总结一下，就是：<strong>BNLJ 算法相比较 SNLJ 来说是以空间换时间。SNLJ 的判断发生在数据磁盘之上，而 BNLJ 是发生在内存之中，相比较而言，内存的速度要远快于磁盘。所以，BNLJ 算法的性能要高于 SNLJ 算法</strong>。</p><p>在这个过程中，驱动表（这里是<code>test_joinv1</code>）跟<code>join_buffer</code>的比值直接影响<code>SNLJ</code>的性能。比值越小，<code>join_buffer</code> 所承载驱动表中的数据的比例就越大，扫描驱动表的次数就越少，性能就越高。</p><p>说到了这里，我们对比了实现 <code>join</code> 底层的三种算法之后，我们回到文章开头的问题：大厂/DBA 为什么不建议使用 <code>join</code> 呢？</p><p>其实，如果使用 <code>Index Nested-Loop Join</code> 算法的话，通过被驱动表索引的树结构去查询这个过程，从各个方面来讲都是可以使用的；但是如果使用 <code>Block Nested-Loop Join</code> 算法的话，性能就不是很理想了，特别是遇见数据量很大的数据表的时候，就会多次扫描数据表，进而导致性能低下，这个时候不建议使用；如果单纯地提高内存空间是可以提高性能的，但是这种办法对系统的性能的消耗又要增加不少。</p><h3 id="总结" tabindex="-1">总结 ​</h3><p>本文主要介绍了<code>MySQL</code>数据库实现连表查询<code>join</code>的三种算法。</p><ul><li><code>INLJ</code>主要是利用被驱动表的索引进行查询，避免了全表扫描，从而提高性能，推荐使用这种算法；</li><li><code>SNLJ</code>算法完全是嵌套查询，需要扫描每一个表，性能和复杂度非常地不理想，我不建议使用过这种算法；</li><li><code>BNLJ</code>是在<code>SNLJ</code>的基础上进行改编而来的，它是利用内存空间来换的时间，利用 <code>join_buffer</code> 内存空间作为载体，在内存中进行匹配，数据量较大时对系统的性能消耗会很大。</li></ul><p>在实际应用场景中，不建议<code>join</code>超过三个表，应该<code>join</code>的数据表越多，扫描的数据表就越多，性能也就越差；能使用索引的就使用索引，如果不使用索引并且驱动表跟<code>join_buffer</code>的比值比较大的情况下，建议拆分查询，因为这样可以减少扫描数据表的次数，从侧面提高性能。</p>`,54),p=[t];function h(l,k,d,o,c,E){return e(),i("div",null,p)}const j=s(n,[["render",h]]);export{F as __pageData,j as default};
