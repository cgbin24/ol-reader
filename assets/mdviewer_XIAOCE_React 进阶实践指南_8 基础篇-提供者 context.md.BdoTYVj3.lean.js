import{_ as h}from"./app.BdTF1atn.js";import{I as t,j as k,D as s,m as i,L as l,Z as a,i as p}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/React 进阶实践指南/8 基础篇-提供者 context.md","filePath":"mdviewer/XIAOCE/React 进阶实践指南/8 基础篇-提供者 context.md"}'),e={name:"mdviewer/XIAOCE/React 进阶实践指南/8 基础篇-提供者 context.md"},E=a("",56),r=s("li",null,"② 第二种就是 React 本身对 React element 对象的缓存。React 每次执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新。",-1),d=a("",37);function g(y,o,F,c,C,u){const n=t("ConsumerDemo");return p(),k("div",null,[E,s("ul",null,[s("li",null,[i("① 第一种就是利用 memo，pureComponent 对子组件 props 进行浅比较处理。 const Son = React.memo(()=> "),l(n),i(")")]),r]),d])}const v=h(e,[["render",g]]);export{x as __pageData,v as default};
