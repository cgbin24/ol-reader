import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as n}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/React 进阶实践指南/42 总结篇-如何有效阅读源码.md","filePath":"mdviewer/XIAOCE/React 进阶实践指南/42 总结篇-如何有效阅读源码.md"}'),t={name:"mdviewer/XIAOCE/React 进阶实践指南/42 总结篇-如何有效阅读源码.md"},e=n(`<h2 id="过时的-react-api" tabindex="-1">过时的 React API ​</h2><h3 id="前言" tabindex="-1">前言 ​</h3><blockquote><p>一流工程师天生充满了责任感和好奇心,他们大都满怀信心但却虚怀若谷，他们直接但不粗鲁，他们不推诿，他们不在乎工作边界，以团队任务而不是自己的工作任务为模板。我不止一次领教过一流工程师的威力，他们不止能把事情做对，还能把事情做好。他们能在完成开发的同时还能把团队不必要的沟通、返工和流程成本降到最低，更能防患于未然，把各种凶险消弭于无形。 --《浪潮之巅》：吴军博士讲述硅谷IT发展史</p></blockquote><p>在目前读者的反馈中，说到小册里面的源码部分看起来比较头疼，很难理解。实际我在小册中放了一些源码主要为了让大家了解 React 中一些核心细节和主要流程。只有知道这些，才能更熟练的运用 React ，才能更好地解决工作中一些复杂的场景问题。接下来我把我阅读源码的心得分享给大家，希望能对大家有帮助。</p><h3 id="如何高效阅读源码-彩蛋" tabindex="-1">如何高效阅读源码（彩蛋） ​</h3><p>在阅读源码过程中，我遵循这几个技巧，感觉很有效果。</p><h4 id="_1-知己知彼" tabindex="-1">1 知己知彼 ​</h4><p>首先在阅读源码之前，第一步就是要明白看的是什么？ 是否熟悉里面的 api？ 是否在真实的项目中使用过？ 如果对于同一个库，工作中使用过的开发者看源码，要比没有使用过直接看源码，容易的多。</p><ul><li>比如想看 <code>react-redux</code> 源码，就要先知道 react-redux 中 Provider 是做什么的 ？ <code>connect</code> 怎么使用的，它有几个参数，每个参数有什么意义？</li><li>比如想看 <code>mobx-react</code> 源码，就要先知道 <code>mobx-react</code> 中 <code>inject</code> ，<code>observer</code> 的作用。</li></ul><p>开发者对一个库或者一个框架越熟悉，看源码也就越容易，甚至如果真的精通一个框架本身，那么很有可能不看源码就猜到框架内部是如何实现的，正所谓庖丁解牛。</p><h4 id="_2-渐进式-分片式阅读" tabindex="-1">2 渐进式｜分片式阅读 ​</h4><p>看源码千万不要想着<strong>一口气吃成个胖子</strong>，作者看 React 源码，陆陆续续看了一年，当然不是天天都在看，但是中间也没有间隔太久，如果想要快速看完源码，懂得原理，那么<strong>只能从看源码到放弃</strong>。</p><p>作者看源码遵循 <strong>渐进式 ，分片式</strong> 原则。</p><ul><li>渐进式： 拿 React 为例子🌰，如果一上来就看 React 核心调和调度流程，那么一下就会蒙，就会找不到头绪，看着看着就会变成看天书，所以可以先看一下基础的，比如 fiber 类型，React 如何创建 fiber ，每个 fiber 属性有什么意义。然后再慢慢渗透核心模块，这样效果甚佳。</li><li>分片式：对于一个框架的源码学习，要制定计划，化整为零，每天学习一点点，每一次学习都做好笔记，两次学习的间隔最好不要太长时间。</li></ul><h4 id="_3-带着问题-带着思考去阅读" tabindex="-1">3 带着问题，带着思考去阅读 ​</h4><p>带着问题学习源码是最佳的学习方案，而且作者可以保证，这种方式每一次看都会有收获。即使很多开发者看源码坚持不下去，就是因为没有带着问题，没有去思考。</p><p>如果没有问题的去看源码，看着看着就会变得盲目，而且很有可能犯困。这样是坚持不下去的。</p><p>那么如何带着问题去思考呢？ 作者这里举了个例子🌰，比如现在想看 React Hooks 源码。那么我写一段 React Hooks 代码片段，看一下可以从中汇总出哪些问题？</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React , { useContext , useState , useRef, useEffect, useLayoutEffect, useMemo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newContext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* ① React Hooks 必须在函数组件内部执行？，React 如何能够监听 React Hooks 在外部执行并抛出异常。  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newContext)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ②  React Hooks 如何把状态保存起来？保存的信息存在了哪里？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number1 , setNumber1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ③ React Hooks 为什么不能写在条件语句中？</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props.isShow) [ number1 , setNumber1 ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cacheState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> trueValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> number </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cacheState.current</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },[ number ,number1 ])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调重新执行。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },[ props.a ])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ⑥ React 如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    useLayoutEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },[])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;《React 进阶实践指南》&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>从上面的一段代码中，可以提炼出的问题有：</p><ul><li>① React Hooks 为什么必须在函数组件内部执行？React 如何能够监听 React Hooks 在外部执行并抛出异常。</li><li>② React Hooks 如何把状态保存起来？保存的信息存在了哪里？</li><li>③ React Hooks 为什么不能写在条件语句中？</li><li>④ useMemo 内部引用 useRef 为什么不需要添加依赖项，而 useState 就要添加依赖项。</li><li>⑤ useEffect 添加依赖项 props.a ，为什么 props.a 改变，useEffect 回调函数 create 重新执行。</li><li>⑥ React 内部如何区别 useEffect 和 useLayoutEffect ，执行时机有什么不同？</li></ul><p>如果带着以上问题去阅读源码，相信阅读之后肯定会有收获。这种带着问题去阅读好处是：</p><ul><li><strong>能够从源码中找到问题所在，更一针见血的了解原理。</strong></li><li><strong>能让阅读源码的过程变得不是那么枯燥无味，能够更加坚定阅读。</strong></li></ul><h3 id="披荆斩棘-勇往直前" tabindex="-1">披荆斩棘 ，勇往直前！ ​</h3><p>这本小册作者从 2020 年就开始整理，2021 年四月初开始正式写，写了正好四个月。 四个月里作者拒绝一切社交活动，没有一个周末休息过，把 React 知识点，从点到线再到面的串联起来，展现给大家，可能写的比较仓促，有一些错别字，如果给大家阅读带来不便，还请大家见谅，我会一直维护这本小册，修复错别字和不正确的地方，对小册的内容做技术翻新，对小册内容做补充，特别是持续维护的章节（第十四章，第二十六章，第二十七章）。</p><p><strong>“路漫漫其修远兮，吾将上下而求索”</strong> ，希望阅读到这里的每一个读者，不要把掌握小册的知识点作为学习 React 的终点，而是要当成学习的起点，带着对 React 全新的认识去使用，平时工作中要多敲多练，多学习一些 React 设计模式，多写一些自定义 Hooks 。在 React 技术成长之路上披荆斩棘 ，勇往直前！</p><p>最后的最后感谢大家支持我，认可我，祝福大家早日进阶 React 技术栈，在成长的道路上我与你们同行。🙏🙏🙏</p><p>如果在阅读过程中有什么问题欢迎大家加我微信，交个朋友，微信：<strong>TH0000666</strong>，也可以关注笔者公众号 <strong>前端Sharing</strong>，持续分享前端硬核文章～</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fe8d3fa5d1440e4af905bb810f29b68~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="11118.jpg"></p>`,29),p=[e];function h(l,k,r,E,d,c){return a(),i("div",null,p)}const f=s(t,[["render",h]]);export{u as __pageData,f as default};
