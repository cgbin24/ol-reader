import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as n}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/React 进阶实践指南/35 原理篇-更新流程：进入调度任务.md","filePath":"mdviewer/XIAOCE/React 进阶实践指南/35 原理篇-更新流程：进入调度任务.md"}'),e={name:"mdviewer/XIAOCE/React 进阶实践指南/35 原理篇-更新流程：进入调度任务.md"},t=n(`<h2 id="过时的-react-api" tabindex="-1">过时的 React API ​</h2><p>小贴士：有一些同学反馈调和和调度的章节听着有点懵，不能很好的串联起来，那么笔者打算写本章节作为前两个章节的补充和完善。</p><h3 id="一-前言" tabindex="-1">一 前言 ​</h3><p>之前的<strong>调度和调和</strong>章节分别讲解了调度的本质（时间分片，请求帧）和调和的流程（两大阶段 render 和 commit ）。本章节将继续围绕着核心的两部分展开。</p><p>那么首先来回顾一下两者的概念：</p><ul><li><strong>调度：</strong></li></ul><p>用一段简单的例子描述调度到底做了什么事？假设每一个更新，可以看作一个人拿着材料去办事处办理业务。那么办事处处理每一个人的业务需要时间，并且工作人员，需要维护办事处的正常运转，不能全身心投入给顾客办理业务，那么办事处应该如何处理呢？</p><p>1 首先需要所有来访的顾客排成一队。然后工作人员开始逐一受理业务，不能让工作人员一直办理业务，如果一直办理，假设任务过多的情况，那么会一直占用工作人员时间，前面说到办事处需要正常运转，如果这样就无法正常运转了。</p><p>2 那么工作人员每次办理一个任务后，就先维持办事处的正常运转，等到工作人员有闲暇的时间，再来办理下一个业务。</p><p><strong>那么调度的作用就显而易见了</strong>，首先调度一定是在多个任务情况下，单个更新任务就没调度可言了；多个任务情况下，如果一口气执行完所有更新任务，那么就会阻塞浏览器的正常渲染，给用户体验上就是卡住了。那么调度任务就是每一次执行一个任务，然后先让浏览器完成后续的渲染操作，然后在空暇时间，再执行下一个任务。</p><p>在 v18 调度任务还有一些调整。还是拿办理业务这个例子。</p><p><code>Legacy</code> 模式下：在 v17 及其以下版本，所有的任务都是紧急任务，那么所有来办理的人员都是平等的，所以工作人员只需要按序办理业务就可以了。</p><p><code>v18 Concurrent</code> 模式下：在 v18 模式下，正常紧急的任务都可以看作是会员，一些优先级低的任务比如 <code>transtion</code> 过渡任务，可以看作非会员。如果会员和非会员排列到一起，那么优先会办理会员的业务（正常的紧急优先任务），正常情况下，会办理完所有的会员业务，才开始办理非会员任务；但是在一些极端的情况下，怕会员一直办理，非会员无法办理（被饿死的情况），所以设置一个超时时间，达到超时时间，会破格执行一个非会员任务。</p><ul><li><strong>调和：</strong></li></ul><p><strong>上面介绍了调度的本质，再来举一个例子描述一个调和流程</strong>。 假设我们的应用看作一台设备，那么每一次更新，看作一次检修维护更新，那么维修师傅应该如何检修呢？ 维修师傅会用一个机器 （workLoop可以看作这个机器） ，依次检查每一个需要维护更新的零件（fiber可以看作零件），每一个需要检修的零件都会进入检查流程，如果需要更新，那么会更新，如果有子零件更新（子代 fiber），那么父代本身也会进入到机器运转（ workloop ）流程中。</p><p><code>Legacy</code> 模式下：在这个模式下，所有的零件维修，没有优先级的区分，所有的更新工作都被维修师傅依次检查执行。</p><p><code>Concurrent</code> 模式下：我们都清楚，对于设备的维修，实际有很多种类，比如影响设备运转的，那么这种维修任务迫在眉睫，还有一种就是相比不是那么重要的，比如机器打蜡，清理等，那么在 Concurrent 下的 workloop，就像师傅在用机器检修零件，但是遇到更高优先处理的任务，就会暂定当前零件的检修，而去检修更重要的任务一样。</p><p>上面用两个例子描述了调度和调和的流程，那么两者之间的关系是什么呢？</p><ul><li><p><strong>调度</strong>：首先调度目的针对<strong>多个更新任务</strong>的情况，调度让多个任务井然有序的执行，执行任务的同时，也不要影响浏览器的绘制。调度决定着更新任务的执行时期。</p></li><li><p><strong>调和</strong>：一旦更新任务执行，那么就会进入调和流程，说白了就是根据 state 的改变，去切实地更新视图。</p></li></ul><p>接下来将重点介绍一下 Legacy 模式下调度任务是如何衔接的。</p><h3 id="二-更新之溯源" tabindex="-1">二 更新之溯源 ​</h3><p>在 Legacy 下的 React 应用中，更新本质上有两种：</p><ul><li>第一种就是初始化的时候第一次页面的呈现。</li><li>第二种就是初始化完毕，state 的更新，比如点击按钮，触发 <code>setState</code> 或者 <code>useState</code>。 接下来一一分析上面两个流程。</li></ul><h4 id="_1-从-reactdom-render-看初始化流程" tabindex="-1">1 从 ReactDOM.render 看初始化流程 ​</h4><p>假设现在开始初始化我们的应用，那么 Legacy 模式下是从 ReactDOM.render 开始的，一个传统的应用的开始应该是这个样子。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReactDOM </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react-dom&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 通过 ReactDOM.render  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReactDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>那么 ReactDOM.render 到底做了什么呢？ 在 ReactDOM.render 做的事情是形成一个 Fiber Tree 挂载到 app 上。来看一下主要流程。</p><blockquote><p>react-dom/src/client/ReactDOMLegacy.js -&gt; legacyRenderSubtreeIntoContainer</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> legacyRenderSubtreeIntoContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    parentComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// null</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    children</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;App/&gt; 跟部组件</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app dom 元素</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    forceHydrate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    callback</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // ReactDOM.render 第三个参数回调函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container._reactRootContainer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fiberRoot</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 创建 fiber Root */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> container._reactRootContainer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> legacyCreateRootFromDOMContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(container,forceHydrate);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        fiberRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root._internalRoot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 处理 callback 逻辑，这里可以省略 */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 注意初始化这里用的是 unbatch */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        unbatchedUpdates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /*  开始更新  */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>调用 ReactDOM.render 本质上就是 <code>legacyRenderSubtreeIntoContainer</code> 方法。这个方法的主要做的事情是：</p><ul><li>创建整个应用的 <code>FiberRoot</code> 。</li><li>然后调用 <code>updateContainer</code> 开始初始化更新。</li><li>这里注意⚠️的是，用的是 <code>unbatch</code> （非批量的情况），并不是批量更新的 <code>batchUpdate</code> 。</li></ul><p>那么所有更新流程矛头都指向了 <code>updateContainer</code> ，那么接下来看一下 updateContainer 主要做了哪些事。</p><blockquote><p>react-reonciler/src/ReactFiberReconciler.js -&gt; updateContainer</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">container</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parentComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 计算优先级，在v16及以下版本用的是 expirationTime ，在 v17 ,v18 版本，用的是 lane。  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> lane</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestUpdateLane</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 创建一个 update */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> update</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eventTime, lane);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    enqueueUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current, update, lane);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 开始调度更新 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleUpdateOnFiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current, lane, eventTime);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过上面代码的简化，可以清晰的看出来 updateContainer 做了哪些事。</p><ul><li>首先计算更新优先级 <code>lane</code> ，老版本用的是 <code>expirationTime</code>。</li><li>然后创建一个 <code>update</code> ，通过 <code>enqueueUpdate</code> 把当前的 update 放入到待更新队列 <code>updateQueue</code> 中。</li><li>接下来开始调用 <code>scheduleUpdateOnFiber</code> ，开始进入调度更新流程中。 到此为止，可以总结出，初始化更新的时候，最后调用的是 scheduleUpdateOnFiber，开始进入更新流程。具体逻辑一会会讲到。</li></ul><h4 id="_2-从-usestate-setstate-看更新流程" tabindex="-1">2 从 useState | setState 看更新流程 ​</h4><p>上面说到了初始化流程，接下来如果发生一次更新，比如一次点击事件带来的 state 的更新。我们这里分<strong>类组件和函数组件</strong>分别看一下：</p><p><strong>类组件之 <code>setState</code>：</strong></p><p>在 state 章节讲到过，当触发 setState 本质上是调用 <code>enqueueSetState</code>。</p><blockquote><p>react-reconciler/src/ReactFiberClassComponent.js -&gt; enqueueSetState</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enqueueSetState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inst,payload,callback){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> update</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eventTime, lane);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    enqueueUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fiber, update, lane);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleUpdateOnFiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fiber, lane, eventTime);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以看到 setState 流程和初始化的流程一样。那么再看一下 hooks 的 <code>useState</code>。</p><p><strong>函数组件之 <code>useState</code></strong></p><blockquote><p>react-reconciler/src/ReactFiberHooks.js -&gt; dispatchAction</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dispatchAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lane </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestUpdateLane</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fiber);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    scheduleUpdateOnFiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fiber, lane, eventTime);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上面只保留了 dispatchAction 的核心逻辑，可以清楚的发现，无论是初始化，useState，setState 最后都是调用 <code>scheduleUpdateOnFiber</code> 方法。那么这个就是整个更新的入口。那么这个方法做了些什么事情呢？</p><h4 id="_3-更新入口-scheduleupdateonfiber" tabindex="-1">3 更新入口 scheduleUpdateOnFiber ​</h4><blockquote><p>react-reconciler/src/ReactFiberWorkLoop.js -&gt; scheduleUpdateOnFiber</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleUpdateOnFiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fiber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">lane</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">eventTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (lane </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SyncLane) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LegacyUnbatchedContext) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // unbatch 情况，比如初始化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (RenderContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CommitContext)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /* 开始同步更新，进入到 workloop 流程 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            performSyncWorkOnRoot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               /* 进入调度，把任务放入调度中 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">               ensureRootIsScheduled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, eventTime);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">               if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                   /* 当前的执行任务类型为 NoContext ，说明当前任务是非可控的，那么会调用 flushSyncCallbackQueue 方法。 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                   flushSyncCallbackQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>scheduleUpdateOnFiber 的核心逻辑如上，正常情况下，大多数任务都是 <code>SyncLane</code>。即便在异步任务里面触发的更新，比如在 <code>Promise</code> 或者是 <code>setTimeout</code> 里面的更新，也是 <code>SyncLane</code>，两者之间没有太大的联系。所以上述核心代码中，只保留了 <code>SyncLane</code> 的逻辑。</p><p>那么在 <code>scheduleUpdateOnFiber</code> 内部主要做的事情是：</p><ul><li>在 <code>unbatch</code> 情况下，会直接进入到 performSyncWorkOnRoot ，接下来会进入到 <strong>调和流程</strong>，比如 <code>render</code> ，<code>commit</code>。</li><li>那么任务是 <code>useState</code> 和 <code>setState</code>，那么会进入到 <code>else</code> 流程，那么会进入到 <code>ensureRootIsScheduled</code> 调度流程。</li><li>当前的执行任务类型为 <code>NoContext</code> ，说明当前任务是非可控的，那么会调用 <code>flushSyncCallbackQueue</code> 方法。</li></ul><p>通过上面知道了，<strong>performSyncWorkOnRoot</strong> ： 这个方法会直接进入到调和阶段，会从 rootFiber 开始向下遍历。 <strong>ensureRootIsScheduled</strong> ：会进入到调度流程。 <strong>flushSyncCallbackQueue</strong> ：用于立即执行更新队列里面的任务。至于为什么，接下来会讲到，请细心阅读。</p><p>在介绍 <code>ReactDOM.render</code> 的时候，<strong>初始化的更新会通过 unbatchedUpdates 包裹，那么初始化的更新会直接进入调和阶段同步更新，而不会放入到调度任务中。</strong></p><p><strong><code>legacy</code> 模式下的可控任务和非可控任务。</strong></p><ul><li><p>可控任务：在事件系统章节和 state 章节讲到过，对于 React 事件系统中发生的任务，会被标记 <code>EventContext</code>，在 batchUpdate api 里面的更新任务，会被标记成 <code>BatchedContext</code>，那么这些任务是 React 可以检测到的，所以 <code>executionContext !== NoContext</code>，那么不会执行 <code>flushSyncCallbackQueue</code>。</p></li><li><p>非可控任务：如果在<strong>延时器（timer）队列或者是微任务队列（microtask</strong>），那么这种更新任务，React 是无法控制执行时机的，所以说这种任务就是非可控的任务。比如 <code>setTimeout</code> 和 <code>promise</code> 里面的更新任务，那么 <code>executionContext === NoContext</code> ，接下来会执行一次 <code>flushSyncCallbackQueue</code> 。</p></li></ul><p>那么用流程图描述一下过程：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155f7112d254465abbdb951c0f3a9137~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="1.jpg"></p><h3 id="三-进入调度更新" tabindex="-1">三 进入调度更新 ​</h3><h4 id="_1-控制进入调度" tabindex="-1">1 控制进入调度 ​</h4><p>上面非初始化类型的更新任务，那么最终会走到 ensureRootIsScheduled 流程中，所以来分析一下这个方法。</p><blockquote><p>react-reconciler/src/ReactFiberWorkLoop.js -&gt; ensureRootIsScheduled</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ensureRootIsScheduled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">currentTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 计算一下执行更新的优先级 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newCallbackPriority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> returnNextLanesPriority</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 当前 root 上存在的更新优先级 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> existingCallbackPriority</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.callbackPriority;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 如果两者相等，那么说明是在一次更新中，那么将退出 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(existingCallbackPriority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newCallbackPriority){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newCallbackPriority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SyncLanePriority) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 在正常情况下，会直接进入到调度任务中。 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        newCallbackNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleSyncCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performSyncWorkOnRoot.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, root));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 这里先忽略 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 给当前 root 的更新优先级，绑定到最新的优先级  */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root.callbackPriority </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newCallbackPriority;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>ensureRootIsScheduled 主要做的事情有：</p><ul><li>首先会计算最新的调度更新优先级 <code>newCallbackPriority</code>，接下来获取当前 root 上的 <code>callbackPriority</code> 判断两者是否相等。如果两者相等，那么将直接退出不会进入到调度中。</li><li>如果不想等那么会真正的进入调度任务 <code>scheduleSyncCallback</code> 中。注意的是放入调度中的函数就是<strong>调和流程</strong>的入口函数 <code>performSyncWorkOnRoot</code>。</li><li>函数最后会将 newCallbackPriority 赋值给 callbackPriority。</li></ul><p><strong>什么情况下会存在 existingCallbackPriority === newCallbackPriority，退出调度的情况？</strong></p><p>我们注意到在一次更新中最后 callbackPriority 会被赋值成 newCallbackPriority 。那么如果在正常模式下（非异步）一次更新中触发了多次 <code>setState</code> 或者 <code>useState</code> ，那么第一个 setState 进入到 ensureRootIsScheduled 就会有 root.callbackPriority = newCallbackPriority，那么接下来如果还有 setState | useState，那么就会退出，将不进入调度任务中，<strong>原来这才是批量更新的原理，多次触发更新只有第一次会进入到调度中。</strong></p><p><strong>对于整个批量更新和批量更新打破原理，在第四部分会讲到。</strong></p><h4 id="_2-进入调度任务" tabindex="-1">2 进入调度任务 ​</h4><p>那么当进入到 scheduleSyncCallback 中会发生什么呢？顺着线索往下看：</p><blockquote><p>react-reconciler/src/ReactFiberSyncTaskQueue.js -&gt; scheduleSyncCallback</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scheduleSyncCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (syncQueue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 如果队列为空 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        syncQueue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [callback];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 放入调度任务 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        immediateQueueCallbackNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Scheduler_scheduleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 如果任务队列不为空，那么将任务放入队列中。 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        syncQueue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>flushSyncCallbackQueueImpl</code> 会真正的执行 <code>callback</code> ，本质上就是调和函数 <code>performSyncWorkOnRoot</code>。</p><p><code>Scheduler_scheduleCallback</code> 就是在调度章节讲的调度的执行方法，本质上就是通过 <strong><code>MessageChannel</code></strong> 向浏览器请求下一空闲帧，在空闲帧中执行更新任务。</p><p>scheduleSyncCallback 做的事情如下：</p><ul><li>如果执行队列为空，那么把当前任务放入队列中。然后执行调度任务。</li><li>如果队列不为空，此时已经在调度中，那么不需要执行调度任务，只需要把当前更新放入队列中就可以，调度中心会一个个按照顺序执行更新任务。</li></ul><p>到现在，已经知道了调和更新任务如何进入调度的。也知道了在初始化和改变 state 带来的更新原理。</p><p>接下来有一个问题就是，<strong>比如在浏览器空闲状态下发生一次 state 更新，那么最后一定会进入调度，等到下一次空闲帧执行吗？</strong></p><p>答案是否定的，如果这样，那么就是一种性能的浪费，因为正常情况下，发生更新希望的是在一次事件循环中执行完更新到视图渲染，如果在下一次事件循环中执行，那么更新肯定会延时。但是 <code>React</code> 是如何处理这个情况的呢？</p><h4 id="_3-空闲期的同步任务" tabindex="-1">3 空闲期的同步任务 ​</h4><p>在没有更新任务空闲期的条件下，为了让更新变成同步的，也就是本次更新不在调度中执行，那么 React 对于更新，会用 <code>flushSyncCallbackQueue</code> 立即执行更新队列，发起更新任务，<strong>目的就是让任务不延时到下一帧</strong>。但是此时调度会正常执行，不过调度中的任务已经被清空，</p><p>那么有的同学可以会产生疑问，既然不让任务进入调度，而选择同步执行任务，那么调度意义是什么呢?</p><p>调度的目的是处理存在多个更新任务的情况，比如发生了短时间内的连续的点击事件，每次点击事件都会更新 state ，那么对于这种更新并发的情况，第一个任务以同步任务执行，那么接下来的任务将放入调度，等到调度完成后，在下一空闲帧时候执行。</p><h5 id="可控更新任务" tabindex="-1">可控更新任务 ​</h5><p>那么知道了，发生一次同步任务之后，React 会让调度执行，但是会立即执行同步任务。原理就是通过 <code>flushSyncCallbackQueue</code> 方法。对于可控的更新任务，比如事件系统里的同步的 setState 或者 useState，再比如 batchUpdate，如果此时处理空闲状态，在内部都会触发一个 <code>flushSyncCallbackQueue</code>来立即更新。我们看一下:</p><p><strong>事件系统中的</strong></p><blockquote><p>react-reconciler/src/ReactFiberWorkLoop.js -&gt; batchedEventUpdates</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> batchedEventUpdates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     /* 批量更新流程，没有更新状态下，那么直接执行任务 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevExecutionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executionContext;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EventContext;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 执行事件本身，React 事件在这里执行，useState 和 setState 也会在这里执行 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     /* 重置状态 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevExecutionContext;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext) { </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* 批量更新流程，没有更新状态下，那么直接执行任务 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      flushSyncCallbackQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>ReactDOM暴露的api <code>batchedUpdates</code></strong></p><blockquote><p>react-reconciler/src/ReactFiberWorkLoop.js -&gt; batchedUpdates</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> batchedUpdates</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 和上述流程一样 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      flushSyncCallbackQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如上可以看到，如果浏览器没有调度更新任务，那么如果发生一次可控更新任务，最后会默认执行一次 <code>flushSyncCallbackQueue</code> 来让任务同步执行。</p><h5 id="非可控更新任务" tabindex="-1">非可控更新任务 ​</h5><p>如果是非可控的更新任务，比如在 <code>setTimeout</code> 或者 <code>Promise</code> 里面的更新，那么在 scheduleUpdateOnFiber 中已经讲过。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (executionContext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NoContext) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 执行 flushSyncCallbackQueue ，立即执行更新 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    flushSyncCallbackQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>综上这也就说明了，为什么在异步内部的 <code>setState</code> | <code>useState</code> 会打破批量更新的原则，本质上是因为，执行一次 <code>setState</code> | <code>useState</code> 就会触发一次 <code>flushSyncCallbackQueue</code> 立即触发更新，所以就会进入到调和阶段，去真正的更新 fiber 树。</p><h3 id="四-同步异步模式下的更新流程实践" tabindex="-1">四 同步异步模式下的更新流程实践 ​</h3><p>为了强化本章节的学习，接下来我们来一起研究一下 legacy 模式下的更新流程。</p><h4 id="初始化情况" tabindex="-1">初始化情况 ​</h4><p>首先看一下初始化流程。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e763eb7b683487f847380c15a94656a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="2.jpg"></p><ul><li>ReactDOM.render -&gt; unbatchContext 开关打开 -&gt; updateContainer。</li><li>updateContainer：scheduleUpdateOnFiber -&gt; performSyncWorkOnRoot -&gt; renderRoot -&gt; commitRoot -&gt; 浏览器绘制。</li><li>unbatchContext 开关关闭。</li></ul><p>同步情况 接下来一起看一下在同步（可控任务）和异步（非可控任务）下更新流程。</p><p>首先看一下同步的情况</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 同步条件下 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {number}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleClick} &gt;点击&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如上当点击按钮的时候，会触发两次 <code>setNumber</code> ，那么这两次 <code>setNumber</code> 都做了些什么呢？</p><p>两次更新流程图如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93eead4ab14f42628cdd7ac4e0c00d25~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="3.jpg"></p><p>整个流程过程：</p><ul><li><strong>事件上下文</strong>：开启事件开关 -&gt; 进入第一次 <code>setNumber</code>。</li><li><strong>第一次 <code>setNumber</code> 上下文</strong>： <code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> )。</li><li><strong>第二次 <code>setNumber</code> 上下文</strong>： <code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; 退出。</li><li><strong>事件上下文</strong>：关闭事件开关 -&gt; <code>flushSyncCallbackQueue</code>。</li><li><strong>flushSyncCallbackQueue</strong> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code> -&gt; 浏览器绘制。</li></ul><h5 id="异步情况" tabindex="-1">异步情况 ​</h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 异步条件下 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>两次更新流程图如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2996f90757614edfbcd0230e02645d9c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="4.jpg"></p><p>整个流程过程：</p><ul><li><strong>事件上下文</strong>：开启事件开关 -&gt; 关闭事件开关 -&gt; <code>flushSyncCallbackQueue</code> (此时更新队列为空)。</li><li><strong><code>setTimeout</code>上下文</strong>：执行第一次 <code>setNumber</code>。</li><li><strong>第一次 <code>setNumber</code> 上下文</strong>：<code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -&gt; <code>flushSyncCallbackQueue</code> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code>。</li><li><strong>回到 <code>setTimeout</code> 上下文</strong>：执行第二次 <code>setNumber</code>。</li><li><strong>第二次 <code>setNumber</code> 上下文</strong>：<code>scheduleUpdateOnFiber</code> -&gt; <code>ensureRootIsScheduled</code> -&gt; <code>scheduleSyncCallback</code> (放入回调函数 <code>performSyncWorkOnRoot</code> ) -&gt; <code>flushSyncCallbackQueue</code> -&gt; 执行回调函数 <code>performSyncWorkOnRoot</code> -&gt; 进入调和阶段 -&gt; <code>renderRoot</code> -&gt; <code>commitRoot</code>。</li><li>js执行完毕，浏览器绘制。</li></ul><p>所以这种情况下 render 了两遍。到此为止 legacy 模式下更新流程真相大白。</p><h3 id="五-总结" tabindex="-1">五 总结 ​</h3><p>通过本章节的学习，收获的知识点如下：</p><ul><li>初始化和 <code>state</code> 改变的更新流程。</li><li>可控任务和非可控任务的更新原理。</li><li>如何进入调度任务。</li><li>强化 state | 调度 ｜ 调和 章节的学习。</li></ul>`,121),l=[t];function p(h,k,d,r,c,o){return a(),i("div",null,l)}const b=s(e,[["render",p]]);export{F as __pageData,b as default};
