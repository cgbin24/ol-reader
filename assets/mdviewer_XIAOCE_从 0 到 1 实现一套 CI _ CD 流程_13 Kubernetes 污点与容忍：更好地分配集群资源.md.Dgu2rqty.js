import{_ as e}from"./app.BdTF1atn.js";import{j as s,i as d,Z as i}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/13 Kubernetes 污点与容忍：更好地分配集群资源.md","filePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/13 Kubernetes 污点与容忍：更好地分配集群资源.md"}'),o={name:"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/13 Kubernetes 污点与容忍：更好地分配集群资源.md"},a=i(`<h3 id="前言" tabindex="-1">前言 ​</h3><p>前面的部分，我们已经可以从工程角度合理地去部署一个应用了。可是场景总是复杂的，有时候还会遇到以下问题：</p><p>自动调度集群节点部署很不错。但我其中几台服务器计划只给后端服务准备使用，这要怎么调度呢? &gt; 后端服务依赖的服务器配置都很高，让前端服务也能调度过去显然不合适。如何干预 Pod 部署到指定的其中几个服务器上去呢？.......</p><p>这种问题在实际情况中还比较常见的。因为架构设计，前端服务器所需资源低一些是常事。而资源强占总是不合理的。</p><p>这时候我们就需要借助 <code>Kubernetes</code> 中的<strong>污点与容忍度</strong>去实现了</p><h3 id="什么是污点-容忍度又是什么" tabindex="-1">什么是污点？容忍度又是什么？ ​</h3><p>我们一般说污点，一般指生活中的脏东西。但是在 <code>Kubernetes</code> 中，污点的意义却有所不同。</p><p>在 <code>Kubernetes</code> 中， <code>Pod</code> 被部署到 <code>Node</code> 上面去的规则和逻辑是由 <code>Kubernetes</code> 的调度组件根据 <code>Node</code> 的剩余资源，地位，以及其他规则自动选择调度的。但是有时候在设计架构时，前端和后端往往服务器资源的分配都是不均衡的，甚至有的服务只能让特定的服务器来跑。</p><p>在这种情况下，我们选择自动调度是不均衡的，就需要人工去干预匹配选择规则了。这时候，就需要在给 <code>Node</code> 添加一个叫做污点的东西，以确保 <code>Node</code> 不被 <code>Pod</code> 调度到。</p><p>当你给 <code>Node</code> 设置一个污点后，除非给 <code>Pod</code> 设置一个相对应的<strong>容忍度</strong>，否则 <code>Pod</code> 才能被调度上去。这也就是污点和容忍的来源。</p><p>污点的格式是 <code>key=value</code>，可以自定义自己的内容，就像是一组 <code>Tag</code> 一样。</p><h3 id="给-node-设置污点" tabindex="-1">给 Node 设置污点 ​</h3><p>在给 <code>Node</code> 设置污点之前，我们再创建一个新的 <code>deployment</code> 版本，版本是 <code>v3</code> 。并将之前的 <code>pod</code> 名称， <code>service</code> 名称从 <code>v2</code> 也改成 <code>v3</code> ：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> v3.yaml</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> v3.yaml</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 里面的Pod名称，service改成v3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v3.yaml</span></span></code></pre></div><p>随后，我们用 <code>kubectl get pods</code> 命令获取Pod列表，用 <code>kubectl describe pod</code> 命令看下 <code>Pod3</code> 的运行详情：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63e9f2cfc744853b1ad513a4f31c9bf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们看 <code>Node</code> 一栏， <code>k8s</code> 将我们新创建的 <code>Pod</code> 调度部署到了新增加的 <code>Node2</code> 节点上。接下来，我们给 <code>Node2</code> 设置污点，让 <code>Pod</code> 不会调度到 <code>Node2</code> 节点上。</p><p>当然，给 <code>Node</code> 设置污点是第一步操作，只有设置了污点 <code>Pod</code> 才不会被调度上去。给 <code>Node</code> 添加污点的命令很简单，我们只需要使用 <code>kubectl taint</code> 命令即可给 Node 设置一个污点：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> taint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Node_Name] [key]=[value]:NoSchedule</span></span></code></pre></div><p>其中，<code>Node_Name</code> 为要添加污点的 <code>node</code> 名称；<code>key</code> 和 <code>value</code> 为一组键值对，代表一组标示标签；<code>NoSchedule</code> 则为不被调度的意思，和它同级别的还有其他的值：<code>PreferNoSchedule</code> 和 <code>NoExecute</code> （后面我们会写到）</p><p>我们给 <code>Node3</code> 添加完一个污点后，提示报 <code>node/node2 tainted</code> 代表添加成功：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580e27742614477a9d157e7fa9bef307~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们删除掉已经创建的 <code>v3</code> 版本的 <code>Pod</code> ，让 <code>Kubernetes</code> 重建 <code>Pod</code> ，看看新 <code>Pod</code> 还会不会被调度到 <code>node2</code> 上面去：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delete</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> describe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME]</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2bf634c9357442d9c93f0ff47980ecd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>这时候我们看到， <code>Pod</code> 被调度到了 <code>Node1</code> 上面去。因为 <code>Node2</code> 添加了污点，不会被调度到 <code>Node2</code> 上面去。此时污点生效。</p><h3 id="给-pod-设置容忍度" tabindex="-1">给 Pod 设置容忍度 ​</h3><p>可以看到，给 <code>Node</code> 添加完污点后，新创建的 <code>Pod</code> 都不会调度到添加了污点的 <code>Node</code> 上面。所以我们想让 <code>Pod</code> 被调度过去，需要在 <code>Pod</code> 一侧添加相同的容忍度才能被调度到。</p><p>我们编辑 <code>front-v3</code> 的 <code>deployment</code> 配置文件，在 <code>template.spec</code> 下添加以下字段：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">tolerations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;KEY&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  operator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Equal&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;VALUE&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  effect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;NoSchedule&quot;</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed03909024742948ba15ccae74afeff~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>字段的含义是在给 <code>Pod</code> 设置一组容忍度，以匹配对应的 <code>Node</code> 的污点。 <code>key</code> 和 <code>value</code> 是你配置 <code>Node</code> 污点的 <code>key</code> 和 <code>value</code>； <code>effect</code> 是 <code>Node</code> 污点的调度效果，和 <code>Node</code> 的设置项也是匹配的。</p><p><code>operator</code> 是运算符，<code>equal</code> 代表只有 <code>key</code> 和 <code>value</code> 相等才算数。当然也可以配置 <code>exists</code> ，代表只要 <code>key</code> 存在就匹配，不需要校验 <code>value</code> 的值</p><p>修改保存后，我们使用 <code>kubectl apply -f</code> 命令让配置项生效，接着删除已存在的 <code>Pod</code>，查看下新<code>Pod</code>的调度结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1e698b15ad344338eeb1fad7f0a0661~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>可以看到，在容忍度的作用下， <code>Pod</code> 重新被调度到了 <code>Node2</code> 节点上。</p><h3 id="修改-删除-node-的污点" tabindex="-1">修改/删除 Node 的污点 ​</h3><p>修改污点的方式也很简单，像创建一个污点一样，我们依然使用 <code>kubectl taint</code> 命令就可以完成修改：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> taint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Node_Name] [key]=[value]:NoSchedule --overwrite</span></span></code></pre></div><p>这里的 <code>key</code> 依然是要修改的 <code>key</code> 值，只需要对 <code>value</code> 和作用的值进行修改即可。<strong>后面添加参数 <code>--overwrite</code> 代表覆盖之前的数据</strong>。 删除污点也依然很简单。我们只需要加个 - 号就可以删除污点：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> taint</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [Node_Name] [key]-</span></span></code></pre></div><p>当提示： <code>node/[NODE_NAME] untainted</code> 代表删除成功。</p>`,42),c=[a];function p(t,n,l,h,k,r){return d(),s("div",null,c)}const F=e(o,[["render",p]]);export{E as __pageData,F as default};
