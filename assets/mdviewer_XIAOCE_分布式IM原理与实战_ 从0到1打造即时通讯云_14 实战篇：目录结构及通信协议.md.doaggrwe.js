import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as n}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/14 实战篇：目录结构及通信协议.md","filePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/14 实战篇：目录结构及通信协议.md"}'),t={name:"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/14 实战篇：目录结构及通信协议.md"},p=n(`<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91b4036dc8642f8b636c1aebc6cf06e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="chapter11.png"></p><p>在前面三个章节中，我们完成了<code>通信层</code>的定义与实现，<strong>它是一个通用库，可以被应用到类似的长连系统中</strong>，因此我们把它放在本章之前介绍。那么从本章开始，我们就开始涉及即时通信的业务逻辑了。首先，我会介绍下整个系统的<code>目录结构</code>与<code>分层逻辑</code>，帮助读者建立一个抽象的系统全局视图。</p><h3 id="目录结构" tabindex="-1">目录结构 ​</h3><p>如下图就是整个项目的目录结构，最顶层的包就是<code>kim</code>，定义了大量的接口以及底层逻辑，随着后面功能的添加与优化内容会有变化，不过整体结构不会有变化。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89fa32f9c1604994b2de203bfda461e5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>整个系统分为三大部分：<code>底层</code>、<code>业务层</code>、<code>测试用例</code>，我们通过下面这张图可以更容易理解它：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e0598cd7cda42e1b1c023789bcd8247~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="KIM_directory.png"></p><p>在<strong>分布式IM架构</strong>一章最后有提到过，由于我们从<code>水平</code>与<code>垂直</code>两个维度对系统做了拆分，<strong>为了减少大量重复逻辑</strong>，我对系统做了如下分层。</p><h4 id="系统分层" tabindex="-1">系统分层 ​</h4><p>整个通信系统分为：<code>基础层</code>、<code>通信层</code>、<code>容器层</code>、<code>链路层</code>、<code>控制层</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d897adbbcdc34d1094ff8394495f981e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="系统分层_目录.png"></p><p>其中，<code>通信层</code>已经在前面三个章节介绍完成。而<code>基础层</code>主要内容就是本章节的<code>通信协议</code>，其它个别<strong>工具类与方法</strong>不会单独讲解，在介绍上层逻辑时如果有涉及再说明，<strong>毕竟如果只针对这些基础讲没有什么逻辑性，太枯燥</strong>。与盖房子一样，本小册也会根据这张“图纸”的规划<code>从下往上</code>分层次的讲解。</p><h4 id="业务层" tabindex="-1">业务层 ​</h4><p>其中业务层包括了<strong>链路层与控制层</strong>，代码在<code>/services/</code>目录中：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c17379b92a4d88b841d870745c23c7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p><strong>启用服务的命令如下：</strong></p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main.go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">King</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> IM</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Cloud</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Usage:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  kim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [command]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Available</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Commands:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gateway</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     Start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gateway</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  help</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        Help</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> about</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> any</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> command</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  router</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      Start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> router</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      Start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> server</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  service</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     Start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> service</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Flags:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  -h,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --help</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      help</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kim</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      --version</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   version</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> kim</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Use</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;kim [command] --help&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> for</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> more</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> information</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> about</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> command.</span></span></code></pre></div><p>比如进入<code>services/</code>目录，执行<code>go run main.go gateway</code> 就可以使用<strong>默认配置</strong>启动一个网关了。我们分别了解下<strong>网关</strong>、<strong>逻辑服务</strong>、<strong>rpc服务</strong>的目录结构。</p><h5 id="网关" tabindex="-1">网关 ​</h5><p>网关结构的内部结构就很简单了，读者看完<code>通信层</code>与<code>容器层</code>几章节的内容就后就可以明白为什么了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca11b0364f27478488beae5f68e8590a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h5 id="逻辑服务" tabindex="-1">逻辑服务 ​</h5><p>逻辑服务与网关类似，不过在逻辑服务中，多了一些handler用于处理指令，与web系统中的controller类似。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cece5ab1a4c1481d9e411811e644a09c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h5 id="rpc服务" tabindex="-1">rpc服务 ​</h5><p>rpc服务就是Rest服务，本小册不会针对它做详细的讲解，但是会在具体的业务逻辑（比如<strong>离线消息</strong>）中涉及到到这部分的代码逻辑。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba62a0ad8ada4df482b17c5c69b67f1a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>它主要包括如下内容：</p><ol><li>配置conf</li><li>分布式ID生成器</li><li>ORM层及Model</li><li>缓存redis</li><li>路由处理器handler</li></ol><blockquote><p>Router在这里就先不介绍了，它与rpc服务相同，都是rest接口，而且更简单。</p></blockquote><h3 id="基础层之通信协议" tabindex="-1">基础层之通信协议 ​</h3><p>与Http超文本传输协议类似，在通信系统中，也需要设计一套协议，应用于用户与服务及服务之间的沟通。而一个协议通常由两部分组成：<code>协议头</code>、<code>协议体</code>。其中协议头中会有一个<code>指令</code>字段，类似于HTTP协议中的Path地址。在通信系统中，协议头按格式分为两种：<code>定长</code>和<code>非定长</code>。比如在定长的协议头中通常使用4字节的数字表示<code>指令</code>，定长协议头的优势就是<strong>解析方便且效率高</strong>，而<code>非定长</code>的协议头包容性更大更灵活。</p><p>用代码可以表示如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LogicPkt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	Header</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Body []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`json:&quot;body,omitempty&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>我们给它定义一个名称<code>逻辑协议</code>，与后面的<code>基础协议</code>分开。</p></blockquote><p>其中Body格式就是<code>[]byte</code>，因为对通信层来说它不重要，<code>body</code>的内容是在<code>指令处理器</code>中被解析并处理，通信层处理的主要对象就<code>Header</code>，如下图所示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6502241e1367463a8ad59fdff9b44624~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="pkt_decode_encode.png"></p><h4 id="协议头" tabindex="-1">协议头 ​</h4><p>Header指消息头，在系统中我们直接使用<strong>protobuf</strong>来序列化Header，格式如下：</p><table tabindex="0"><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>command</td><td>string</td><td>指令</td></tr><tr><td>channelId</td><td>string</td><td>连接标识</td></tr><tr><td>sequence</td><td>uint32</td><td>序列号</td></tr><tr><td>flag</td><td>enum</td><td>标识</td></tr><tr><td>status</td><td>enum</td><td>状态码</td></tr><tr><td>dest</td><td>string</td><td>目标：群、用户</td></tr><tr><td>bodyLength</td><td>uint32</td><td>消息体的长度</td></tr></tbody></table><ul><li><strong>指令command</strong></li></ul><p>消息指令类似于http中的path，由于指定消息的处理逻辑，实际上很多系统的指令都是int类型，可以减少消息包大小。由于我们把逻辑服务分成多个子服务，<strong>因此在网关层就需要一个标识知道消息包是转发给谁</strong>。所以在command中定义了一个通过格式：<code>服务名.指令</code>，比如login.signin表示一个登录协议，其中login就是服务名。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86890858959c4d12bf931d90014aad1e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="协议定义.png"></p><p>具体协议的内容与逻辑我们在具体章节再介绍！</p><ul><li><strong>连接标识channelId</strong></li></ul><p>在通信系统中，登录与消息的收发都是使用Account或UserId之类的<strong>用户唯一身份标识</strong>。通常在业务层<strong>会话管理</strong>中记录的是<strong>用户身份标识</strong>，但是在网关的<strong>连接管理</strong>中记录的是一个临时生成的<code>连接唯一标识</code>，用channelId表示。如图如示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903a254a48b347939b609ebe8c3f2ca0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="会话分层.png"></p><blockquote><p>需要说明的是<code>用户标识也是全局唯一，为什么不直接使用用户标识？</code></p></blockquote><p>如果在<code>demo章节</code>读者已经测试出我说的bug，这里的问题估计你已经知道了答案。没有也没关系，答案就是用户标识在<strong>空间维度</strong>是<strong>唯一</strong>的，但是在<strong>时间维度</strong>是<strong>不唯一</strong>，简单来说就是同一个用户账号存在<code>同时登录</code>的情况，导致系统在某个时刻有多个相同账号的连接，会造成逻辑混乱。因此在用户登录到网关上时，连接管理中记录的是一个临时生成的全局唯一标识，而在逻辑服务中使用<code>用户标识作为索引</code>。</p><ul><li><strong>序列号sequence</strong></li></ul><p>序列号是发送方生成的消息唯一标识。长连接通信协议是一个<code>全双工</code>协议，它与Http1.x<code>半双工</code>协议的区别在于<code>全双工协议中消息的的发送与接收是没有顺序要求的</code>，我们用下图来说明：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4b3025e5554a05943d7c462502e3b8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="全双工通信.png"></p><blockquote><p>HTTP1.x协议Keepalive中，由于请求之间有顺序要求，所以如果响应1阻塞就会影响之后的请求响应，这就是<code>行头阻塞</code>的原理。</p></blockquote><p>那么全双工通信协议是怎么解决这个问题的呢，实际上就是协议头中有个<code>序列号</code>字段，在请求时写入自增的序列号到request的Header中，服务端处理完请求之后，在<strong>响应包头中带上请示包中的序列号</strong>，客户端收到消息之后就可以配对了。</p><ul><li><p><strong>标识flag</strong></p></li><li><p>flag是消息的类型标识，有三个值：</p></li><li><p>Request: 表示一条请求消息，通常是客户端发起。</p></li><li><p>Response: 表示一条响应消息，通常是<code>7.指令处理器</code>返回。</p></li><li><p>Push: 表示一条推送消息，通常是<code>7.指令处理器</code>转发出去。</p></li><li><p><strong>状态码status</strong></p></li></ul><p>系统定义的一些常规状态码。</p><ul><li><strong>目标dest</strong></li></ul><p>目标用于指定消息的接收方，在IM系统中有两类：<strong>用户和群</strong>，分别用Account和GroupId表示，系统通过协议Command来判断这个字段是用户还是群。</p><h4 id="基础协议" tabindex="-1">基础协议 ​</h4><p>在前面的章节我们介绍过<strong>web端API</strong>不开放websocket协议中的ping/pong心跳协议。因此我们需要在业务层协议中支持ping/pong协议。但是如果我们直接在<strong>逻辑协议</strong>基础上添加心跳指令不太合适，主要有两点：</p><ol><li>心跳在<strong>网关层就返回</strong>，不转发给<strong>逻辑服务</strong>处理。</li><li>心跳包要尽量小，<strong>逻辑协议</strong>的Header太重。</li></ol><p>因此，我们设计一个简单的<strong>基础协议</strong>，来处理一些轻量的消息：</p><table tabindex="0"><thead><tr><th>消息指令 Command</th><th>消息长度 Length</th><th>消息载体 Body</th></tr></thead><tbody><tr><td>2bytes</td><td>2bytes</td><td>n bytes</td></tr></tbody></table><p>结构如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BasicPkt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Code   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Body   []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>ping/pong的code设计如下：</strong></p><table tabindex="0"><thead><tr><th>协议code</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>ping</td></tr><tr><td>2</td><td>pong</td></tr></tbody></table><p>Body为空的情况下，包的长度就是:<strong>4(magic)+2(code)+2(Length)</strong></p><h4 id="序列化" tabindex="-1">序列化 ​</h4><p><strong>逻辑协议</strong>与<strong>基础协议</strong>都实现了Packet接口，它有两个方法，Decode反序列化和Encode序列化，<strong>逻辑协议</strong>中的Header和Body使用protobuf序列化框架可以减少手动编写Decode和Encode的代码，而<strong>基础协议</strong>则使用小头字节序手动处理。下面就是Packet接口的定义。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Packet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	Decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Reader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	Encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">w</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Writer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="协议区分" tabindex="-1">协议区分 ​</h4><p>那么问题来了，如果只有一种协议按照格式解析即可，但是有两种协议格式怎么办法？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0e1386b1bc347b9b3014babfad549e2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="两种协议.png"></p><blockquote><p>需要说明的是tcp协议是流式传输，上层是不知道TCP缓存中的数据长度是多少的，<strong>而且网关层接收的数据不一定是合法的</strong>。</p></blockquote><p>答案就是通过前面介绍的<code>魔数</code>来支持两种不同的协议。只要指定两个不同的魔数，就可以在网关层区分是<code>基础协议</code>还是<code>逻辑协议</code>。示例代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Magic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	MagicLogicPkt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Magic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">c3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">a3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//逻辑协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	MagicBasicPkt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Magic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">c3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">a7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//基础协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Reader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	magic </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Magic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	_, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReadFull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, magic[:])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> magic {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wire.MagicLogicPkt:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LogicPkt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r); err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wire.MagicBasicPkt:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BasicPkt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Decode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r); err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, errors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">New</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;magic code is incorrect&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上面是一个解包的方法，还有一个封包的方法，主要作用是把<strong>Magic封装到消息的头部</strong>。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Marshal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Packet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	buf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	kind </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Elem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kind.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssignableTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LogicPkt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		_, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wire.MagicLogicPkt[:])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> kind.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">AssignableTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BasicPkt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		_, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wire.MagicBasicPkt[:])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	_ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Encode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里使用到了golang中的反射。</p><blockquote><p>LogicPkt和BasicPkt包中的Decode与Encode方法在这里就不说明了，读者可以查看源代码。</p></blockquote><h4 id="知识点之-io-readfull" tabindex="-1">知识点之 <code>io.ReadFull</code> ​</h4><p>有些读者，搞不清楚io相关的知识点，刚好在上面的代码中使用到了<code>io.ReadFull(r, magic[:])</code>，因此在这里我们来了解下它的作用与用法。首先看下它的定义：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReadFull reads exactly len(buf) bytes from r into buf.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// It returns the number of bytes copied and an error if fewer bytes were read.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// The error is EOF only if no bytes were read.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If an EOF happens after reading some but not all the bytes,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReadFull returns ErrUnexpectedEOF.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// On return, n == len(buf) if and only if err == nil.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// If r returns an error having read at least len(buf) bytes, the error is dropped.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadFull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Reader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadAtLeast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, buf, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>主要意思就是调用这个方法可以<code>确切</code>的从<code>r（Reader）</code>中读出len(buf)个字节的数据把<code>buf填满</code>，否则就会返回Error。读者可能在想这不是<strong>废话</strong>吗，<code>直接从Reader中读取不就可以了，还用的着多此一举吗？</code></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Reader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	Read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>实际上，还真不是。在本小册的前面章节中，我多次强调TCP是基于流式传输，<strong>应用层发送的数据包可能会被合并，也可能被拆分发送</strong>。这就导致在接收方，调用conn.Read()时可能拿不到我们想要的全部数据。我们看如下的示意图，假设在Server端要读取10个字节的数据，但是由于TCP读缓冲中目前只有5个字节的数据（hello）,因此conn.Read()只会返回hello，而不是想要的结果helloworld。此时就可以使用io.ReadFull(conn,buf)，它会返回给我们希望的结果<code>helloworld</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b31be77b8d1a4271ad7d9fccd746a523~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="io_ReadFull.png"></p><p><code>这里为了说明拆包逻辑，所以只画了10个字节的数据被拆开，太长我也画不出来</code>。实际上在TCP报文中data部分的最大长度为MSS（Maxitum Segment Size,最大分段大小)，而这个值又受网卡中<code>MTU</code>大小影响，在<strong>通信协议之状态</strong>篇中有过介绍。</p><blockquote><p>请问读者，MSS的最大值是多少？</p></blockquote><p>最后，我们看下<code>io.ReadFull</code>的实现：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReadAtLeast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Reader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">buf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ErrShortBuffer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;---</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">看这里</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		nn, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buf[n:])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nn</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> min {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EOF {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ErrUnexpectedEOF</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>本章完！</strong></p>`,93),h=[p];function k(l,e,d,r,E,g){return a(),i("div",null,h)}const u=s(t,[["render",k]]);export{b as __pageData,u as default};
