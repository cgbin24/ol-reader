import{_ as e}from"./app.BdTF1atn.js";import{j as t,i as d,Z as o}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/1 前言：什么是 CI&CD && 为什么要学 CI&CD.md","filePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/1 前言：什么是 CI&CD && 为什么要学 CI&CD.md"}'),c={name:"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/1 前言：什么是 CI&CD && 为什么要学 CI&CD.md"},i=o('<h3 id="什么是-ci-cd" tabindex="-1">什么是 CI/CD ​</h3><p>在开发阶段，许多编译工具会将我们的源码编译可使用的文件。例如 <code>vue-cli</code> 的项目会被 <code>webpack</code> 打包编译为浏览器的文件，<code>Java</code> 项目会被编译为 <code>.class/jar</code> 文件以供服务器使用。</p><p>但是，开发人员过多关注构建和部署过程是很浪费时间的。以之前古老的的构建部署流程为例子，需要经历以下步骤：</p><ol><li>开发人员将源代码，经过编译、压缩等一系列流程打包为<strong>制品</strong>（意思为打包后的成品）</li><li>将制品上传到服务器。</li><li>在服务器将编译后的文件，手动可用的容器服务内（例如 <code>Nginx</code>，<code>Tomcat</code>，<code>Apache</code> 等服务）</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43e0a040cebb4bc8a611ffb46002db18~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt=""></p><p>显而易见，这种流程不仅繁琐，且容易出错，是非常影响开发效率的。开发人员要花一些时间浪费在这上面。那么有没有高效率，简单便捷一些的方式呢？</p><p>这就要提到 <code>CI/CD</code> 了。<code>CI</code> 的意思是 <code>持续构建</code> 。负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 <code>制品</code> ，并将制品推送至到制品库里面。常用工具有 Gitlab CI，Github CI，Jenkins 等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为 制品，保存制品的地方被称为 “制品库”</p><p>CD 则有2层含义： <code>持续部署（Continuous Deployment）</code> 和 <code>持续交付（Continuous Delivery）</code> 。 <code>持续交付</code> 的概念是：将制品库的制品拿出后，部署在测试环境 / 交付给客户提前测试。 <code>持续部署</code> 则是将制品部署在生产环境。可以进行持续部署的工具也有很多： <code>Ansible</code> 批量部署， <code>Docker</code> 直接推拉镜像等等。当然也包括我们后面要写到的 <code>Kubernetes</code> 集群部署。</p><h3 id="为什么要学-ci-cd" tabindex="-1">为什么要学 CI/CD ​</h3><p>相信大家在了解它们的用途后，会有几点以下疑问：</p><ul><li>这不是运维干的活吗？</li><li>好像和业务代码不相关，那我了解它有何意义？</li><li>全是服务器知识，我不了解相关知识怎么学习？</li></ul><p>相信这是许多前后端同学一致的疑问。的确，对于曾经的我，也有过这些疑问。门槛高，和工作内容不相关。那他的意义在哪里？</p><p>但是当我通过学习这些知识和在团队中实践这些流程后，我在知识面上得到了很大的扩展。对操作系统，对实际的构建部署，甚至对工程化拥有了全新的认识。甚至可以提出建议，如何更好的优化这些流程。这些都是你可以获得成长和学习的地方。你也可以选择将这部分知识点写入你的简历，作为面试和筛选的加分项。从更高的角度看整个项目的全貌，往往产生思考的维度是和一般的角度不同的。你会成长更快，渐渐地突破思维天花板。</p><p>当然，如果你对 <code>Linux</code> 操作系统不是很熟悉，建议先补习下基础的系统安装，操作命令，基础概念等知识（系统推荐 <code>CentOS</code> / <code>Ubuntu</code> ），在小册中将不会对基础<code>Linux命令</code>有过多解释。当然，如果遇到部分不懂的现场搜索也可以，相信你学起来这部分知识可以更加得心应手。</p><h3 id="小册整体架构设计" tabindex="-1">小册整体架构设计 ​</h3><p>在开始学习之前，我们先来了解下小册的整体内容技术架构设计：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87eada87807a46a0a98159633274b5cf~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>上面是一张全景架构图，小册内容和章节将围绕该图展开编写内容。其中不包含单元测试和代码扫描环节，只关注构建和部署环节。</p><p>换成文字叙述就是这样的：</p><ol><li>你写完了代码，提交到了 <code>Git</code> 代码库</li><li>随后，代码库配置的 <code>WebHook</code> 钩子或人工手动启动了 <code>Jenkins</code> 的构建流程</li><li><code>Jenkins</code> 启动构建流程。按照你之前配置好的构建脚本，将代码编译成功。</li><li>编译成功后，将编译后的文件打包为 <code>docker</code> 镜像，并将镜像上传到私有镜像库。</li><li>随后，使用 <code>kubectl</code> 指定远程的k8s集群，发送镜像版本更新指令</li><li>远程的k8s集群接收到指令后，去镜像库拉取新镜像</li><li>镜像拉取成功，按照升级策略（滚动升级）进行升级，此时不会停机。</li><li>升级完毕。</li></ol><h3 id="服务器搭配方案" tabindex="-1">服务器搭配方案 ​</h3><p>学习这本小册，动手能力要具备，当然服务器资源也要准备好。这里推荐几种服务器搭配方案用来学习测试使用：</p><p><strong>系统选用 CentOS 7：mirrors.aliyun.com/centos/7.9.…</strong></p><h4 id="_1-全本地虚拟机-全上云" tabindex="-1">1. 全本地虚拟机 / 全上云 ​</h4><p>这里所有主机都必须为云服务器/本地虚拟机。要保持统一</p><table tabindex="0"><thead><tr><th>配置</th><th>技术栈</th><th>类型</th><th>标签</th></tr></thead><tbody><tr><td>2核4G</td><td>Jenkins + Nexus + Docker</td><td>本地虚拟机 / Cloud</td><td>构建机</td></tr><tr><td>2核4G</td><td>Docker + Kubernetes</td><td>本地虚拟机 / Cloud</td><td>Kubernetes Master</td></tr><tr><td>1核1G</td><td>Docker + Kubernetes</td><td>本地虚拟机 / Cloud</td><td>Kubernetes Node</td></tr></tbody></table><h4 id="_2-半云半本地虚拟机" tabindex="-1">2. 半云半本地虚拟机 ​</h4><p><strong>构建机器放本地，要部署的机器放云上面。否则的话构建机找不到要部署的机器 缺点：无法使用 Git 的 Webhook</strong></p><table tabindex="0"><thead><tr><th>配置</th><th>技术栈</th><th>类型</th><th>标签</th></tr></thead><tbody><tr><td>2核4G</td><td>Jenkins + Nexus + Docker</td><td>本地虚拟机</td><td>构建机</td></tr><tr><td>2核4G</td><td>Docker + Kubernetes</td><td>Cloud</td><td>Kubernetes Master</td></tr><tr><td>1核1G</td><td>Docker + Kubernetes</td><td>Cloud</td><td>Kubernetes Node</td></tr></tbody></table>',29),r=[i];function n(p,a,l,s,_,b){return d(),t("div",null,r)}const D=e(c,[["render",n]]);export{k as __pageData,D as default};
