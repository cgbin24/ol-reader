import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as e}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/10 Kubernetes Secret：储存你的机密信息.md","filePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/10 Kubernetes Secret：储存你的机密信息.md"}'),p={name:"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/10 Kubernetes Secret：储存你的机密信息.md"},t=e(`<h3 id="前言" tabindex="-1">前言 ​</h3><p>在之前几个章节中，我们实现了对一个前端镜像的简单部署流程。</p><p>可是，我们在部署时，难免会遇到一些要存放<strong>机密内容</strong>的需求。例如我们的数据库密码，用户名密码，公钥私钥，<code>token</code> 等等机密内容，甚至还有我们 <code>docker</code> 私有库的密码。而这些内容，显然是不能写死在代码里面，更不可能明文挂载进去的。</p><p>那么我们有没有什么好的解决方案能够使用呢？这一章我们就来学习 <code>Kubernetes</code> 中的一个概念 —— <code>Secret</code></p><h3 id="什么是-secret" tabindex="-1">什么是 Secret ​</h3><p>Secret 是 Kubernetes 内的一种资源类型，可以用它来存放一些机密信息（密码，token，密钥等）。信息被存入后，我们可以使用挂载卷的方式挂载进我们的 Pod 内。当然也可以存放docker私有镜像库的登录名和密码，用于拉取私有镜像。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f83c8c1a2654fdd86e9bcc7295a9cb7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><h3 id="secret-的几种类型" tabindex="-1">Secret 的几种类型 ​</h3><p>在 k8s中，secret 也有多种类型可以配置</p><h4 id="opaque-类型" tabindex="-1">Opaque 类型 ​</h4><p>第一种是 <code>opaque</code> 类型，这种类型比较常用，一般拿来存放密码，密钥等信息，存储格式为 <code>base64</code> 。但是请注意：base64并不是加密格式，依然可以通过decode来解开它。</p><p>例如我们创建一组用户名和密码，用户名为 <code>janlay</code> 和 <code>367734wer</code> 。则可以通过命令 <code>kubectl create secret generic</code> 创建：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> generic</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> default-auth</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --from-literal=username=janlay</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--from-literal=password=367734qwer</span></span></code></pre></div><p>在这里， <code>default-auth</code> 为 自定义的名称，<code>--from-literal</code> 的后面则跟随一组 <code>key=value</code>。当然你也可以按照此格式继续向后拼接你要存储的信息。</p><p>存储成功后，我们可以通过 <code>kubectl get secret</code> 命令来查看你存储过的 <code>Secret</code>。在这里可以看到，刚刚创建的密钥组合 <code>default-auth</code> 已经展示了出来。</p><p>在这里， <code>NAME</code> 代表 <code>Secret</code> 的名称；<code>TYPE</code> 代表 <code>Secret</code> 的类型； <code>DATA</code> 是 <code>Secret</code> 内存储内容的数量； <code>AGE</code> 是创建到现在的时间</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/248c5dbf1fe34232b612082399d75ceb~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>我们可以通过 <code>kubectl edit secret</code> 命令来编辑 <code>default-auth</code> 的内容，来看看里面到底存了什么内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> edit</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> default-auth</span></span></code></pre></div><blockquote><p>这里也可以用 <code>kubectl get secret [secret名称] -o yaml</code> 命令，将内容打印到终端上查看。其中 <code>-o yaml</code> 代表输出为 <code>yaml</code> 格式内容，当然也可以输出 <code>json</code> 等格式内容</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0045cdbf2d4b492aa7d964e09fa3e444~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，data 字段存放了我们存储的信息 <code>base64</code> 后的结果。但是这种方式是不安全的，我们可以通过解码base64 来获取真实值：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MzY3NzM0cXdlcg==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> base64</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span></span></code></pre></div><blockquote><p>这里可以使用 Linux 自带的 base64 命令进行解码。其中 -d 代表 --decode，解码的意思</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/991267c99b514736990a4b37aea1ce97~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>解码后，我们可以清晰的看到原始内容。</p><p>那么除了通过命令创建，可不可以通过配置文件创建呢？答案是可以的。我们新建一个文件，名称叫 <code>admin-auth.yaml</code> ，输入以下配置：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Secret</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admin-auth</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">stringData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  username</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">wss</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  password</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">wss@1234</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Opaque</span></span></code></pre></div><p>在这里， <code>name</code> 代表 <code>Secret</code> 的名称，名称为 <code>admin-auth</code>； <code>type</code> 代表它的类型，类型为 <code>Opaque</code> ； <code>stringData</code> 代表存储的内容，格式为 <code>key:value</code>。</p><p>我们保存后退出，使用 <code>kubectl apply -f</code> 命令生效这份配置。接着使用 <code>kubectl get secret admin-auth -o yaml</code> 查看下内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> admin-auth.yaml</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> admin-auth</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yaml</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5301e32b37847e7a0501b9937a0aac6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，创建是正常成功的。</p><h4 id="私有镜像库认证" tabindex="-1">私有镜像库认证 ​</h4><p>第二种是私有镜像库认证类型，这种类型也比较常用，一般在拉取私有库的镜像时使用。</p><p>在这里我们依然可以通过命令行进行创建。只不过类型变成了 <code>docker-registry</code> ：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker-registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> private-registry</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--docker-username=[用户名] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--docker-password</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[密码</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--docker-email</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[邮箱</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">--docker-server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">[私有镜像库地址</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>创建成功后，我们可以使用 <code>kubectl get secret</code> 命令查看下我们配置的私有库密钥组：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> private-registry</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yaml</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e45c32fda574192a8b076b17f978700~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，k8s 自动帮我们填写了一个key，为 <code>.dockerconfigjson</code> ；value则是一串 base64 值。我们依然可以使用 <code>base64 -d</code> 命令查看下里面到底是啥：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [value] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> base64</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c1e6aa821142069ab0297863cfccc9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>通过解码后可以看到， <code>k8s</code> 会自动帮我们创建一串 <code>dockerconfig</code> 的 <code>json</code> 串。在 k8s 拉取镜像时，则可以使用这个 <code>json</code> 串来用于身份认证。</p><p>当然，私有镜像库密钥组也可以通过配置文件创建。编辑文件名为 <code>private-registry-file.yaml</code> 文件，并输入以下内容：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Secret</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">private-registry-file</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  .dockerconfigjson</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsidXNlcm5hbWUiOiJhZG1pbiIsInBhc3N3b3JkIjoiMzY3NzM0IiwiZW1haWwiOiJqYW5sYXk4ODQxODEzMTdAZ21haWwuY29tIiwiYXV0aCI6IllXUnRhVzQ2TXpZM056TTAifX19</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">kubernetes.io/dockerconfigjson</span></span></code></pre></div><p>大家可能发现在这里创建镜像库认证时，声明的配置文件更像是一份 <code>dockerconfig</code> ，而不只是单纯的镜像库身份认证。</p><p>在这里， data内的字段必须为 <code>.dockerconfigjson</code>，值则是一串 <code>dockerconfigjson</code> 的 <code>base64</code> 值；<code>type</code> 则为 <code>kubernetes.io/dockerconfigjson</code> ，意思是声明一份 <code>dockerconfig</code> 的配置</p><p>保存后退出，使用 <code>kubectl apply -f</code> 命令让该配置生效。并使用 <code>kubectl get secret</code> 命令查看下我们配置的详情：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./private-registry-file.yaml</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> secret</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> private-registry-file</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yaml</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58925cc3ce7447ffbea5b5252fd3b15e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，配置内容和命令行创建的是一样的。创建成功</p><h3 id="使用方法" tabindex="-1">使用方法 ​</h3><p>上面我们写了如何声明一个 Secret。在声明后，我们需要在实际的配置中使用，才有实际意义。在 K8S 中，一共有三种可以使用 Secret 的方式。</p><h4 id="volume-挂载" tabindex="-1">Volume 挂载 ​</h4><p>第一种是通过存储卷的方式挂载进去。我们可以编辑下 <code>front-v1</code> 的 <code>deployment</code> 配置文件去配置下。</p><p><strong>第一步：在<code>Pod</code>层面设置一个外部存储卷，存储卷类型为 <code>secret</code> 。在 <code>template.spec</code> 下填写。这里代表声明了一个外置存储卷，存储卷名称为 <code>admincert</code> ，类型为 <code>secret</code>；<code>Secret</code> 的名称为 <code>admin-auth</code> ：</strong></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admincert</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  secret</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    secretName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admin-auth</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d10344893604f9d91fd93ba94e55265~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p><strong>第二步：在容器配置配置存储卷。在<code>containers.name[]</code>下填写字段 <code>volumeMounts</code> 。这里的 <code>name</code> 值和上面的卷名是对应的。 <code>mountPath</code> 是要挂载到容器内哪个目录，这里代表挂载到用户目录下；<code>readonly</code> 则代表文件是不是只读：</strong></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">volumeMounts</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admincert</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  mountPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/root</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  readOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5339114eede6402fafd54a338bc49924~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>编辑完后，保存并退出。使用 <code>kubectl apply -f</code> 命令生效下配置文件。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span></span></code></pre></div><p>此时， <code>Pod</code> 会被杀死重新创建。我们可以通过 <code>kubectl get pods</code> 来查看现在运行的 <code>Pod</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf49aac49aed41b3b86adfa30bffe274~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>此时可以看到，我们的 <code>Pod</code> 状态为 <code>Running</code> 运行状态。</p><p>在运行正常的情况下，我们可以使用 <code>kubectl exec</code> 命令在 <code>Pod</code> 容器内执行我们要执行的命令。在这里，我们查看下 <code>Pod</code> 镜像内的 <code>/root</code> 文件夹里面都有啥文件：</p><blockquote><p>kubectl exec 命令格式：kubectl exec [POD] -- [COMMAND]</p></blockquote><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME] -- ls /root</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46178fafbb86496dbfc3751882e1e7df~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，分别有2个文件，都是我们在 <code>secret</code> 内配置的 <code>key</code> 。接着使用 <code>kubectl exec</code> 命令，查看下文件内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME] -- cat /root/password</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME] -- cat /root/username</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18afa7b7cf3f4601af88b31eb5a08096~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>此时，代表挂载成功，可以使用。</p><h4 id="环境变量注入" tabindex="-1">环境变量注入 ​</h4><p>第二种是将 <code>Secret</code> 注入进容器的环境变量。同样需要配置下 <code>deployment</code> 文件。找到 <code>containers</code> ，下面新加一个 env 字段：</p><p>其中， <code>env[].name</code> 为环境变量的 <code>key</code> ， <code>valueFrom</code> 为值； <code>secretKeyRef</code> 则代表是一个 <code>Secret</code> 类型的 <code>value</code>。</p><p><code>secretKeyRef.name</code> 则是要引用的 <code>secret</code> 的名称，<code>key</code> 则是 <code>secret</code> 中配置的 <code>key</code> 值。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">USERNAME</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  	valueFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  		secretKeyRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    		name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admin-auth</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      	key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">username</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	- </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">PASSWORD</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    valueFrom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    	secretKeyRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      	name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">admin-auth</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">password</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dc85d3cbffd43e69b8c344299f7c976~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>编辑完后，保存并退出。使用 <code>kubectl apply -f</code> 命令生效下配置文件。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span></span></code></pre></div><p>生效后，在最新的 <code>Pod</code> 内使用 <code>kubectl exec</code> 命令来看看环境变量注入结果：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME] -- env</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3f59f5f395a45ed95660def084c3848~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到，我们配置的2个环境变量均已被注入进去。</p><h4 id="docker-私有库认证" tabindex="-1">Docker 私有库认证 ​</h4><p>第三种是 Docker 私有库类型，这种方法只能用来配置 私有镜像库认证。</p><p>首先，我们先尝试不加认证去拉取一个私有库镜像。编辑下 <code>front-v1</code> 的 <code>deployment</code>，把镜像换成私有库的镜像。保存后使用 <code>kubectl apply</code> 生效配置：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">镜像库地址</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/jenkins-test:latest</span></span></code></pre></div><p>接着使用 <code>kubectl get pods</code> 查看下目前pod的状态：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a49342316e17431ab73f30c7b398fdd8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>可以看到， <code>front-v1</code> 的 <code>Pod</code> 并无法拉取下来镜像。我们使用 <code>kubectl describe</code> 命令查看下该 <code>Pod</code> 的具体状态：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> describe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [POD_NAME]</span></span></code></pre></div><p>找到 <code>Events</code> 那一块，可以其中一条 <code>message</code> 写着：<strong>unauthorized: access to the requested resource is not authorized（要请求的资源没有认证）。此时不登录，无法拉取私有镜像</strong>。</p><p>那怎么办呢？这里我们需要配置下 <code>deployment</code> 文件。</p><p>找到 <code>spec</code> ，下面新加一个 <code>imagePullSecrets</code> 字段。该字段代表了在拉取Pod所需要的镜像时，需要的认证信息。其中，<code>name</code> 字段为上面我们配置过的私有镜像库认证名。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">imagePullSecrets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">private-registry-file</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d263e50b1afe4369b14c39aa5104067f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>编辑后保存，使用 <code>kubectl apply -f</code> 命令生效配置文件。接着看下 Pod 的运行状态。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd6f2c951a594593bbb2d550996024a9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png"></p><p>此时我们发现，Pod 可以成功拉取私有镜像了。</p>`,103),n=[t];function l(h,k,d,c,o,r){return a(),i("div",null,n)}const u=s(p,[["render",l]]);export{F as __pageData,u as default};
