import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as e}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/8 Kubernetes 灰度发布与滚动发布：零宕机发布的奥秘.md","filePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/8 Kubernetes 灰度发布与滚动发布：零宕机发布的奥秘.md"}'),p={name:"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/8 Kubernetes 灰度发布与滚动发布：零宕机发布的奥秘.md"},n=e(`<h3 id="前言" tabindex="-1">前言 ​</h3><p>在前一章，我们学会如何在 <code>Kubernetes</code> 内部署自己的第一个应用。但是在实际应用中，我们还会遇到一些特定场景：</p><blockquote><p>A 用户是VIP，我怎么才能让VIP用户看到内测版本呢？ 我不想停机，怎么发布新版本呢？ 如何让新版本服务只开放小流量访问呢？ ......</p></blockquote><p>显然，这些场景对于我们单纯的访问来看是无法做到的。那么有什么好办法呢？</p><h3 id="什么是灰度发布" tabindex="-1">什么是灰度发布 ​</h3><p>首先我们来看<strong>灰度发布</strong>。灰度发布是一种发布方式，也叫 <code>金丝雀发布</code> 。<strong>起源是矿工在下井之前会先放一只金丝雀到井里，如果金丝雀不叫了，就代表瓦斯浓度高。原因是金丝雀对瓦斯气体很敏感</strong>。这就是金丝雀发布的又来，非常形象地描述了我们的发布行为。</p><p>灰度发布的做法是：会在现存旧应用的基础上，启动一个新版应用。但是新版应用并不会直接让用户访问。而是先让测试同学去进行测试。如果没有问题，则可以将真正的用户流量慢慢导入到新版上。在这中间，持续对新版本运行状态做观察，直到慢慢切换过去，<strong>这就是所谓的A/B测试</strong>。 当然，你也可以招募一些 <strong>灰度用户</strong>， 给他们设置独有的灰度标示（Cookie，Header），来让他们可以访问到新版应用。</p><p>当然，如果中间切换出现问题，也应该将流量迅速地切换到老应用上。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d5513b9e9e7410e959b99ccac9a2765~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h3 id="实现方案" tabindex="-1">实现方案 ​</h3><p>在上一章节，我们使用 <code>k8s</code> 部署了 <code>ingress</code> 。这里我们就利用 <code>ingress annotations</code> 中的 <code>canary</code> 配置项来实现灰度发布逻辑。</p><h4 id="_1-准备新版本的-service" tabindex="-1">1. 准备新版本的 Service ​</h4><p>在开始准备灰度之前，需要准备一套新环境以备流量切分。切换到 <code>deployment</code> 目录，我们新启动一套 <code>v2</code> 的环境配置，在这里可以将原先 <code>v1</code> 的配置文件，拷贝一份替换为 <code>v2</code> 的镜像：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> v1.yaml</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> v2.yaml</span></span></code></pre></div><p>修改 <code>v2.yaml</code>，将 <code>Deployment Name</code>， <code>Service Name</code> 和匹配规则都替换为 <code>v2</code> ，并将镜像版本替换为 <code>v2</code></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">apps/v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Deployment</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    matchLabels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  replicas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      labels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      containers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">registry.cn-hangzhou.aliyuncs.com/janlay/k8s_test:v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">containerPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">---</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Service</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-service-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">TCP</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    port</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    targetPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">NodePort</span></span></code></pre></div><p>接着使用 <code>kubectl apply</code> 命令使其配置生效：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span></span></code></pre></div><h4 id="_2-根据不同方案进行切分" tabindex="-1">2. 根据不同方案进行切分 ​</h4><h5 id="根据-cookie-切分流量" tabindex="-1">根据 Cookie 切分流量 ​</h5><p>基于 <code>Cookie</code> 切分流量。这种实现原理主要根据<strong>用户请求中的 Cookie 是否存在灰度标示 Cookie</strong>去判断是否为灰度用户，再决定是否返回灰度版本服务。</p><p>我们新建一个全新的 <code>ingress</code> 配置文件，名称叫 <code>gary</code> ：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./ingress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./gray.yaml</span></span></code></pre></div><p>输入以下配置：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">extensions/v1beta1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Ingress</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-demo-canary</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  annotations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    kubernetes.io/ingress.class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    nginx.ingress.kubernetes.io/rewrite-target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    nginx.ingress.kubernetes.io/canary</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    nginx.ingress.kubernetes.io/canary-by-cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;users_from_Beijing&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      paths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          serviceName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-service-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          servicePort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">     serviceName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-service-v2</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">     servicePort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span></code></pre></div><p>我们可以看到，在 <code>annotations</code> 这里，有两个关于灰度的配置项。分别是：</p><ul><li>nginx.ingress.kubernetes.io/canary：可选值为 <code>true / false</code> 。代表是否开启灰度功能</li><li>nginx.ingress.kubernetes.io/canary-by-cookie：灰度发布 <code>cookie</code> 的 <code>key</code>。当 <code>key</code> 值等于 <code>always</code> 时，灰度触发生效。等于其他值时，则不会走灰度环境。</li></ul><p>保存后，使用 <code>kubectl apply</code> 生效配置文件查看效果：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./gray.yaml</span></span></code></pre></div><p>执行成功后，可以使用 <code>kubectl get svc</code> 命令来获取 <code>ingress</code> 的外部端口：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress-nginx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> svc</span></span></code></pre></div><blockquote><p><code>-n</code>: 根据资源名称进行模糊查询</p></blockquote><p>其中，<code>PORT</code> 字段是我们可以访问的外部端口。80为 <code>ingress</code> 内部端口，31234 为外部端口。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab31c3f403854ccdac118e9c3068a15a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们访问 http://IP:31234/ 可以正常访问到页面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671136d95607469aaa1dbd061a1f247e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>接下来，我们在chrome控制台中手动设置一个 <code>cookie</code>。key为 <code>users_from_Beijing</code> ，值为 <code>always</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff73757bd88941ba83f1a87f754fdc3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>刷新页面，发现我们访问的是v2。灰度发布环境搭建成功</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b91c07762b24d48a14a6c0f02bb8d87~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h5 id="基于-header-切分流量" tabindex="-1">基于 Header 切分流量 ​</h5><p>基于 <code>Header</code> 切分流量，这种实现原理主要根据<strong>用户请求中的 header 是否存在灰度标示 header</strong>去判断是否为灰度用户，再决定是否返回灰度版本服务。</p><p>当然配置也很简单，只需要修改 <code>annotations</code> 配置项即可：</p><ul><li>nginx.ingress.kubernetes.io/canary-by-header：要灰度 <code>header</code> 的 <code>key</code> 值</li><li>nginx.ingress.kubernetes.io/canary-by-header-value: 要灰度 <code>header</code> 的 <code>value</code> 值</li></ul><p>保存后，使用 <code>kubectl apply</code> 生效配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./gray.yaml</span></span></code></pre></div><p>如何查看效果呢？我们可以使用 <code>curl</code> 命令来加header头去请求访问调用：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --header</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;header的key:header的value&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 127.0.0.1:端口值</span></span></code></pre></div><p>由于我这里配置的灰度 <code>header</code> 为 <code>janlay</code> ， <code>value</code> 为 <code>isme</code> ，所以如以下结果：</p><p>通过对比发现，当 <code>janlay</code> 不是 <code>isme</code> 时，灰度失效。验证成功</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82679dba06094a6f98f3e1d699817112~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h5 id="基于权重切分流量" tabindex="-1">基于权重切分流量 ​</h5><p>这种实现原理主要是根据用户请求，通过根据灰度百分比决定是否转发到灰度服务环境中</p><p>在这里，我们修改 <code>annotations</code> 配置项即可：</p><ul><li>nginx.ingress.kubernetes.io/canary-weight：值是字符串，为 <code>0-100</code> 的数字，代表灰度环境命中概率。如果值为 0，则表示不会走灰度。值越大命中概率越大。<code>当值 = 100</code> 时，代表全走灰度。</li></ul><p>保存后，使用 <code>kubectl apply</code> 生效配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./gray.yaml</span></span></code></pre></div><p>我们用shell脚本语言写个轮询，循环10次调用服务，看灰度命中概率：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 127.0.0.1:端口值</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">done</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841f48ea47db4531af410b5395f94bbc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>通过轮询10次发现，其命中概率大概在 <code>4-6</code> 次左右。这个命中概率只是相对于单词请求而言，拥有50%的概率。所以批量执行存在误差是正常的。</p><h4 id="注意事项-优先级" tabindex="-1">注意事项：优先级 ​</h4><p>上面的三种灰度方案都了解完后，如果同时配置三种方案，那么他们在 <code>ingress</code> 中的优先级是怎样的？ 在官方文档的后面有一个 <code>Note</code> 提示，上面明确有写：</p><blockquote><p>Canary rules are evaluated in order of precedence. Precedence is as follows: <strong>canary-by-header -&gt; canary-by-cookie -&gt; canary-weight</strong></p></blockquote><p><code>k8s</code> 会优先去匹配 <code>header</code> ，如果未匹配则去匹配 <code>cookie</code> ，最后是 <code>weight</code></p><h3 id="总结" tabindex="-1">总结 ​</h3><p>这里我们学习了灰度发布的配置方式和其3种模式：基于 <code>cookie</code> 切分，基于 <code>header</code> 切分，基于权重概率切分。</p><p>接下来我们会学习基于 <code>deployment</code> 的滚动发布模式，讲解如何不宕机平滑发布服务</p><h3 id="参考链接" tabindex="-1">参考链接 ​</h3><ul><li>kubernetes ingress 官方文档：kubernetes.github.io/ingress-ngi…</li></ul><h3 id="什么是滚动发布" tabindex="-1">什么是滚动发布 ​</h3><p>滚动发布，则是我们一般所说的无宕机发布。其发布方式如同名称一样，一次取出一台/多台服务器（看策略配置）进行新版本更新。当取出的服务器新版确保无问题后，接着采用同等方式更新后面的服务器。</p><h3 id="发布流程和策略" tabindex="-1">发布流程和策略 ​</h3><h4 id="就绪状态" tabindex="-1">就绪状态 ​</h4><p>第一步，我们准备一组服务器。这组服务器当前服务的版本是 V1。</p><p>接下来，我们将会使用滚动策略，将其发布到 V2 版本。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b82db5b76244f708cf4cbd259bf854a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h4 id="升级第一个-pod" tabindex="-1">升级第一个 Pod ​</h4><p>第二步开始升级。</p><p>首先，会增加一个 V2 版本的 Pod1 上来，<strong>将 V1 版本的 Pod1 下线但不移除。此时，V1版本的 Pod1 将不会接受流量进来，而是进入一个平滑期等待状态（大约几十秒）后才会被杀掉</strong>。</p><p>第一个 Pod 升级完毕</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91075d4256184ddfb01508d2431e48b5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16bdb14d3c6e472a8ae39ac7bb24e3db~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h4 id="升级剩下的-pod" tabindex="-1">升级剩下的 Pod ​</h4><p>与上同理，<strong>同样是新增新版本Pod后，将旧版本Pod下线进入平滑期但不删除。等平滑期度过后再删除Pod</strong>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86ed4f6c02344a8ab1b1854fa372dc0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ec1d08fa6ba4e29953372c5148a9426~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19cb25fe400c4cc2bc053a8a4cec2689~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa048085bd644b409686878da1d024d5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h3 id="优缺点" tabindex="-1">优缺点 ​</h3><p>滚动发布作为众多发布类型的一种，必然也存在着一些优点和缺点：</p><h4 id="优点" tabindex="-1">优点 ​</h4><ol><li>不需要停机更新，无感知平滑更新。</li><li>版本更新成本小。不需要新旧版本共存</li></ol><h4 id="缺点" tabindex="-1">缺点 ​</h4><ol><li>更新时间长：每次只更新一个/多个镜像，需要频繁连续等待服务启动缓冲（详见下方平滑期介绍）</li><li>旧版本环境无法得到备份：始终只有一个环境存在</li><li>回滚版本异常痛苦：如果滚动发布到一半出了问题，回滚时需要使用同样的滚动策略回滚旧版本。</li></ol><h3 id="kubernetes-中的滚动发布" tabindex="-1">Kubernetes 中的滚动发布 ​</h3><p>在 <code>Kubernetes</code> 的 <code>ReplicaSet</code> 中，默认就是滚动发布镜像。我们只需要通过简单的配置即可调整滚动发布策略</p><p>编辑 <code>deployment</code> 文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span></span></code></pre></div><p>在图示的位置添加以下字段：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea59e732f97544568a4e28e302c7943c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">minReadySeconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  replicas</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">RollingUpdate</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    rollingUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      maxSurge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      maxUnavailable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></div><p>字段的含义分别为：</p><table tabindex="0"><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>minReadySeconds</td><td>容器接受流量延缓时间：单位为秒，默认为0。如果没有设置的话，k8s会认为容器启动成功后就可以用了。设置该值可以延缓容器流量切分</td></tr><tr><td>strategy.type = RollingUpdate</td><td>ReplicaSet 发布类型，声明为滚动发布，默认也为滚动发布</td></tr><tr><td>strategy.rollingUpdate.maxSurge</td><td>最多Pod数量：为数字类型/百分比。如果 maxSurge 设置为1，replicas 设置为10，则在发布过程中pod数量最多为10 + 1个（多出来的为旧版本pod，平滑期不可用状态）。maxUnavailable 为 0 时，该值也不能设置为0</td></tr><tr><td>strategy.rollingUpdate.maxUnavailable</td><td>升级中最多不可用pod的数量：为数字类型/百分比。当 maxSurge 为 0 时，该值也不能设置为0。</td></tr></tbody></table><p>编辑结束后，保存文件。</p><p>接着使<code>Kubernetes</code>生效配置。配置生效后立即继续发布动作，随后监听查看发布状态更改：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rollout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment/front-v2</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb12d03e60ed40fa93cfa97c9ff9cf96~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们通过日志可以看到，3个 <code>replicas</code> 的更新逻辑逻辑为：<strong>单个逐个地去进行更新 Pod。而不是一次性将旧的Pod 全部杀死后，再启动新的 Pod</strong>。</p><p>通过简单的配置，我们即可在k8s中实现滚动发布。</p><h3 id="另一种发布模式" tabindex="-1">另一种发布模式 ​</h3><p>既然 <code>k8s</code> 的默认发布方式就是滚动发布，那么有没有其他的更新方式？</p><p>在 <code>Kubernetes</code> 中，有一种发布方式为 <code>Recreate</code> 。这种发布方式比较暴力，它会直接把所有旧的 <code>Pod</code> 全部杀死。杀死后再批量创建新的 <code>Pod</code> 。</p><p>我们只需要将 <code>strategy.type</code> 改为 <code>Recreate</code> 即可：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># type: Recreate</span></span></code></pre></div><p>接着更新 <code>deployment</code> 并查看发布状态：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v2.yaml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rollout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment/front-v2</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4112d46b9d4409e9e592fc2440111c8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们看到， <code>k8s</code> 会将所有旧的 <code>Pod</code> 杀死，随后再批量启动新的 <code>Pod</code> 。</p><p>这种发布方式相对滚动发布偏暴力。<strong>且在发布空窗期（杀死旧Pod，新Pod还没创建成功的情况下）服务会不可用</strong>。</p><p>接着我们再来介绍下上面提到的 <code>kubectl rollout</code> 命令：</p><h3 id="kubectl-rollout" tabindex="-1">kubectl rollout ​</h3><p><code>kubectl rollout</code> 命令可以用来操纵 <code>deployment</code> 的资源进行管理。包括对版本的快速回退，暂停/恢复版本更新，根据更新历史回退版本等功能。</p><p>例如暂停一个 <code>deployment</code> 的发布：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rollout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pause</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment/名称</span></span></code></pre></div><p>继续一个 <code>deployment</code> 的发布：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rollout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> resume</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment/名称</span></span></code></pre></div><p>查看一个 <code>deployment</code> 的发布状态：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rollout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> status</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment/名称</span></span></code></pre></div><h3 id="结束语" tabindex="-1">结束语 ​</h3><p>在这一章，我们通过 <code>Kuberentes</code> 实现了灰度发布/滚动发布环境，基本上可以满足需求。在下一章，我们会给大家带来新东西 —— 健康度检查。可以让你更好地管理服务状态，控制服务的运行行为</p><p>大家有什么问题呢？欢迎在评论区留言回复 👏</p>`,132),t=[n];function l(h,k,d,c,o,r){return a(),i("div",null,t)}const u=s(p,[["render",l]]);export{F as __pageData,u as default};
