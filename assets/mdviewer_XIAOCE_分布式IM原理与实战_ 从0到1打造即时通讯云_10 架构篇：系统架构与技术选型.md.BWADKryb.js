import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as t,Z as a}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/10 架构篇：系统架构与技术选型.md","filePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/10 架构篇：系统架构与技术选型.md"}'),n={name:"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/10 架构篇：系统架构与技术选型.md"},p=a(`<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79bfab549ebf44038b65e7fcfcae7b63~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="chapter10.png" loading="lazy"></p><h3 id="系统架构" tabindex="-1">系统架构 ​</h3><p>首先，我们给实战项目取个霸气点的名字：<code>King IM Cloud（简写KIM）</code>。</p><p>在分布式的架构及演进一章中，我已经给出了<strong>通信服务</strong>的架构图。那么在本章节我们从全局的视角，看看整个系统完整的架构图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2633b07fd1a144d685ceed9be5f64911~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="structure.png" loading="lazy"></p><p>整个系统核心由6个核心服务组成，它们分别是：ApiGateway、Router、TGateway/WGateway、LoginServer、ChatServer、IMService。</p><ol><li><code>ApiGateway</code>: API接口网关，<strong>对外开放部分</strong>Service提供的服务。</li><li><code>Royal</code>: RPC服务，在后面章节Service也是指这个服务。提供了<strong>用户管理</strong>、<strong>群管理</strong>、<strong>消息管理</strong>、<strong>登录授权</strong>等服务。</li><li><code>Router</code>：网关层智能路由，SDK通过调用Router提供的接口路由到指定的网关。</li><li><code>WGateway/TGateway</code>：长连接网关，它们功能完全相同，WGateway提供Websocket协议的连接服务，TGateway提供TCP协议的连接服务。</li><li><code>LoginServer</code>: 登录服务，提供登录、退出等服务，会话保存在redis中。</li><li><code>ChatServer</code>: 聊天服务，提供单聊、群聊、离线消息同步等功能。</li></ol><p>下面我们通过一个简化的时序图来看看服务之间的调用关系：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aebbfad72064706a3b169b50de588f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="时序.png" loading="lazy"></p><p>主要有两个逻辑：<strong>授权登录</strong>与<strong>单聊消息</strong>，整个系统都是以这两个逻辑为核心展开，实际上内部的逻辑还是比较复杂的。我们从系统<strong>分层及模块</strong>的角度来看下内部大致结构：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832d08bf79d4404988e6251b78a9aa60~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="分层.png" loading="lazy"></p><p>其中通信相关的核心模块：</p><ol><li><strong>连接监听与管理</strong>：监控端口，并接收客户端的连接，维护在内存中。</li><li><strong>消息处理单元</strong>：解析接收的消息并处理。</li><li><strong>负载与路由</strong>：根据策略把消息发送到指定的服务中。</li><li><strong>逻辑服务管理</strong>：维护与逻辑服务的长连接，收/发消息。</li><li><strong>网关监听与管理</strong>：监控端口，并接收网关的连接，维护在内存中。</li><li><strong>指令路由器</strong>：类似于Http中的路由，通过协议头中的指令找到指令处理器。</li><li><strong>会话管理</strong>：管理系统登录的会话，会话存储在缓存Redis中。</li></ol><blockquote><p>具体的细节我们在之后的章节一一道来。</p></blockquote><h3 id="技术选型" tabindex="-1">技术选型 ​</h3><p>开发一套系统，其中使用的技术与框架是非常多的，有些需要我们自己实现，而有些则可以使用开源的成熟方案，减少不必要的工作量。当然在使用的过程中，我们也搞明白它的大致原理，拿来主义虽然没错，但是如果因此导致系统出了bug，这个锅也甩不掉哈。话不多说，我们来看看在本小册IM系统中使用了那些技术。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13eafae55806419d93a4c18a0dd1fda8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="技术选型.png" loading="lazy"></p><h4 id="分布式唯一id" tabindex="-1">分布式唯一ID ​</h4><p>在高并发的业务场景中，系统往往会在短时间内产生大量的消息#### ，比如10w+，为了不阻塞<strong>依赖此消息主键</strong>的下游服务，在把消息插入数据库之前，我们需要给这些消息先打上一个ID，由于服务通常是一个集群，因此需要保证生成的消息ID是<strong>全局唯一</strong>，否则后面写入数据库就会冲突。</p><p>同时，在<strong>分布式存储</strong>系统中，也需要考虑分布式唯一ID的问题，离我们最近的场景就是数据库的<strong>双向同步</strong>，比如Mysql中的<code>双主模式</code>，可以同时向两个数据库写数据，但前提是<strong>主键不能冲突</strong>，如下图。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e59618a2b6f944c4a5d4917e60742bbc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="分布式_冲突.png" loading="lazy"></p><p>实际上很多系统在早期，由于对<strong>可用性</strong>要求不是非常高，技术负责人也没有分布式系统相关经验，往往直接采用数据库的自增ID，但是当系统复杂度与用户量上升到另一个级别后，可能就需要考虑做<strong>多数据中心容灾</strong>，这时候再考虑数据主键冲突问题，改动工作量就有点大了。然而在系统设计前期就使用<strong>分布式ID作为数据的主键，成本实际上是非常低的</strong>。</p><p>在本小册的实战项目中，分布式唯一ID最核心的使用场景就是<strong>消息存储</strong>，其次就是业务表，比如用户，群之类的。</p><p>在IM系统中分布式唯一ID主要考虑有以下几点：</p><ul><li>有序性：提高数据库插入性能。</li><li>可用性：可保证高并发下的可用性。</li><li>友好性：尽量简单易用，不增加系统负担。</li></ul><p>其中<code>有序性</code>是从数据库的Insert性能考虑的，比如我们使用的Mysql中主键是B+树索引，在写入数据时如果主键是有序的，<strong>索引树达到平衡的代价就最小，写入性能也就最高了</strong>。另一方面索引值越小，<code>在内存单位页</code>中保存的索引数量就越多，查询效率就越高，因此我们只考虑使用<strong>数字作为主键</strong>，像一些字符串之类的分布式唯一ID方案就不考虑了。</p><p>最后，我们看看下面三种方案大致的对比情况：</p><table tabindex="0"><thead><tr><th></th><th>数据库自增主键</th><th>分布式ID服务</th><th>雪花算法</th></tr></thead><tbody><tr><td>有序性</td><td>+++</td><td>++</td><td>+++</td></tr><tr><td>可用性</td><td>+</td><td>++</td><td>+++</td></tr><tr><td>友好性</td><td>+++</td><td>+</td><td>++</td></tr></tbody></table><ul><li>数据库自增主键实际上就是依赖数据库的自增ID了，只不过在<strong>起点和步长</strong>设置上与单节点不同，比如A节点从1开始自增，步长为2；B节点从2开始自增，步长为2，多节点同理，不过这个方案后期数据要迁移变动代价也很高。</li><li>分布式ID服务需要<strong>维护一套ID服务</strong>，增加了系统复杂性，当然如果公司里已经有统一的ID服务当然是最理想的情况。</li><li>而雪花算法只要<strong>保证每个计算节点编号NodeID</strong>不重复，基本上不会产生冲突的ID，性能也非常高。</li></ul><p>综合来说<code>雪花算法</code>算是各方面比较平稳的选择。</p><blockquote><p>由于篇幅有限，三种及更多的分布式ID方案的原理就不在这里详细讲解了，感兴趣的读者可以自行查阅相关资料。</p></blockquote><p>本项目使用 github.com/bwmarrin/sn… 生成分布式ID，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb436ef44b847e0aa0d54582d4c04b5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><blockquote><p>读者注意下，Timestamp是在NodeID的高位，因此它可能保证多节点下生成的ID都是随着时间在增大的。</p></blockquote><p>示例如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Create a new Node with a Node number of 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">node, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> snowflake.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Generate a snowflake ID.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Generate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Print out the ID in a few different ways.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Int64  ID: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%d\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, id)</span></span></code></pre></div><p>使用snowflake对有两点要注意：</p><ul><li>Make sure your system is keeping accurate system time</li><li>Make sure you never have multiple nodes running with the same node ID</li></ul><p>第一点，这个就是运维干的事了，一般服务器都会使用NTP来同步时间。</p><blockquote><p>NTP（Network Time Protocol，网络时间协议）是由RFC 1305定义的时间同步协议，用来在分布式时间服务器和客户端之间进行时间同步。NTP基于UDP报文进行传输，使用的UDP端口号为123。</p></blockquote><p>第二点，可以在启用服务手动指定，也可以由运维注入系统（容器）的环境变量中，程序直接读取出。</p><h4 id="rpc框架" tabindex="-1">RPC框架 ​</h4><blockquote><p>RPC框架 = 通信协议+序列化</p></blockquote><p>我们主要从以下两种中选一种：</p><table tabindex="0"><thead><tr><th></th><th>REST</th><th>GPRC</th></tr></thead><tbody><tr><td>通信协议</td><td>HTTP/1.1</td><td>HTTP/2</td></tr><tr><td>序列化</td><td>Json</td><td>Protobuf</td></tr></tbody></table><blockquote><p>严格来说REST接口也不算标准的RPC框架，不过它不是本小册的重点，因此不准备在这方面花费太多时间精力。</p></blockquote><p>如果从性能的方面考虑，GPRC使用HTTP/2协议作为通信协议，而HTTP/2是长连接相比HTTP/1.1性能肯定是要好的，而且它使用protobuf使用消息的序列化框架，在<strong>基础篇：网络传输详解</strong>一章中我们也对比过，protobuf在性能与空间占用方面比json好很多。不过GRPC也有一些缺点：</p><ul><li>长连接会导致SLB负载不均衡。</li><li>GRPC服务注册与发现相对复杂些。</li><li>测试不友好。</li></ul><p>综合考虑，在小册的实战项目中直接使用rest接口。在golang中http框架有很多，比如:</p><ul><li>github.com/gin-gonic/g…</li><li>github.com/labstack/ec…</li><li>github.com/kataras/iri…</li></ul><p>它们性能相差不大，本小册就直接使用iris开发rest服务了，至于为什么选它，先来看下这张摘自iris文档中的图片：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/655c5b6914dd4b249e7f16f8c20d1e9d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>它的调用方式与java中Springboot MVC框架有点类似，搞java的读者会有亲切感，感兴趣的读者可以看看它的使用教程。不过选择iris开发rest接口主要有如下原因：</p><ul><li>性能高</li><li>支持Protobuf</li></ul><p>文档： www.iris-go.com/docs/</p><h4 id="序列化框架" tabindex="-1">序列化框架 ​</h4><p>序列化框架可选项有很多，在这里我列举了三种序列化实现方式：</p><ul><li>protobuf</li><li>json</li><li>自定义</li></ul><p>这三种框架已经在<strong>基础篇：网络传输详解</strong>介绍过了，这里就不详解了。在本项目中，会同时使用到protobuf和自定义序列化，我们在后面具体的协议章节再介绍细节。</p><p>官方文档：developers.google.com/protocol-bu…</p><p>总结下它的优点：</p><ul><li>性能好</li><li>序列化之后的空间小</li><li>支持向后兼容和向前兼容</li><li>支持多种编程语言</li></ul><p>缺点就是要安装环境，要提前编译.proto文件，而且版本升级可能导致以前的逻辑错误。</p><h4 id="websocket框架" tabindex="-1">websocket框架 ​</h4><p>在我们开发的网关中使用到了websocket协议，因此我们需要选择一个websocket库来帮我们减少工作量，在golang中也有一些选择，比如：</p><ul><li>github.com/gorilla/web… 15k Star</li><li>github.com/gobwas/ws 3.9k Star</li></ul><p>gorilla的版本使用上要比gobwas更简单，也就是傻瓜式调用。而gobwas对底层的逻辑开放的更多，使用时需要有一点websocket协议基础知识，如果把gorilla比作ios系统，gobwas就是开源的android系统。在本小册中我们使用gobwas开发通信层逻辑，选择它也是因为gobwas可控性更高，我们在后期<strong>会针对websocket接入逻辑做性能优化</strong>，这里就先卖个关子。</p><h4 id="orm框架" tabindex="-1">orm框架 ​</h4><p>在golang中orm框架也是一堆，我选择两个比较熟悉也是使用比较多的ORM框架，如下：</p><ul><li>gorm</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac1cd15645ca4a9fb67896926b7e752c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><ul><li>xorm</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccb4b69e73f47a5a064ec3379432a5c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>它们功能都相差不大，图中红色标记是一些重点使用的功能。从图中也可以看出一点区别，我挑几个重点的说明一下：</p><ul><li><p>gorm优点</p><ul><li>事务使用方便。</li><li>支持多数据源。</li><li>Prometheus支持。</li><li>驱动支持Clickhouse。</li></ul></li><li><p>xorm优点</p><ul><li>支持缓存。</li><li>支持乐观锁。</li><li>驱动支持TiDB。</li></ul></li></ul><p>比较下来，还是gorm优点对本项目的更有利。比如它的事务调用就比xorm方便很多：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">tx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">gorm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在事务中执行一些 db 操作（从这里开始，您应该使用 &#39;tx&#39; 而不是 &#39;db&#39;）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Giraffe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).Error; err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回任何错误都会回滚事务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Lion&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).Error; err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回 nil 提交事务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="中间件选型" tabindex="-1">中间件选型 ​</h3><p>在如今这个大流量时代，中间件已经是不可或缺的部分。常有如下几类：<strong>数据库</strong>、<strong>缓存</strong>、<strong>MQ</strong>、<strong>注册中心</strong>、<strong>配置中心</strong>、<strong>文件存储</strong>等，而都有很多开源产品。不过，本小册中对中间件选择没有强制要求。<strong>在编码实战部分，这些<code>外部依赖</code>都会通过<code>接口</code>抽象出来，核心系统不会直接依赖具体的实现</strong>。因此这里只是简单介绍下系统使用到的中间件。</p><p><strong>数据库</strong>：主要作用是存储用户、群等基本信息的库。还有一个存储离线消息的库。如果对业务上估计下来每天的消息量在百万左右，完全是可能使用mysql来支撑的。如果有更大量的需求，可以切换到TiDB或者Clickhouse，这非常灵活，完全取决于你对<strong>成本</strong>的考虑。</p><p><strong>缓存</strong>：本项目使用会Redis为会缓存，主要考虑它性能高，也有高可用方案，如最常用的<code>哨兵模式</code>和<code>集群模式</code>，而且还有相应的运维系统，如<code>cachecloud</code>。</p><p><strong>注册中心</strong>：它是微服务体系的一个核心中间件，实现了服务的注册与发现。开源产品很多，通常分为<code>CP(保证数据一致性)</code>和<code>AP（保证服务可用性）</code>两个大类，比如ETCD、Consul，Nacos等就是CP类的注册中心，Eureka就是AP类的注册中心。在本实战项目中，由于涉及到多个服务之间的通信，因此也会使用到注册中心。在实战项目中我们<strong>选择使用golang开发的Consul</strong>，详细内容会在<strong>服务注册与发现</strong>一章中介绍。</p><p><strong>配置中心</strong>：配置中心可以统一管理配置并且热修改，不过它不是一个必须的组件，因此在本项目中暂不集成配置中心。</p><p><strong>文件存储</strong>：通常使用OSS（比如阿里OSS）作为图片的存储方案，在IM系统中发送的图片与视频通常是先上传到OSS，再把url通过消息发送出去，不过在本项目不准备实现图片语音消息的逻辑，因此也不会涉及文件存储。</p><h3 id="最后总结" tabindex="-1">最后总结 ​</h3><p>相信看完本章，读者对整个系统有了一个大致的了解。同时本章也介绍了很多技术与中间件，可能一些新手读者有点慌，这是正常情况，不过只要跟着小册学习，相信读者会有很大的收获。<strong>从下一章节开始，我们将从通信服务的底层开始，完成第一个里程碑</strong>。请读者系好安全带，准备起飞~</p><p><strong>本章完！</strong></p>`,87),l=[p];function e(r,o,h,k,g,d){return t(),i("div",null,l)}const m=s(n,[["render",e]]);export{y as __pageData,m as default};
