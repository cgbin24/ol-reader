import{_ as t}from"./app.BdTF1atn.js";import{j as e,i as d,Z as o}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/20 原理篇：消息可靠投递.md","filePath":"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/20 原理篇：消息可靠投递.md"}'),c={name:"mdviewer/XIAOCE/分布式IM原理与实战: 从0到1打造即时通讯云/20 原理篇：消息可靠投递.md"},p=o('<p>在即时通讯系统中，有两个重要指标：<code>可靠投递</code>与<code>即时投递</code>。可靠投递要求系统在复杂的网络环境或者服务故障情况下也要尽量保证<strong>消息不丢失。即时投递</strong>则是要求发送的消息能尽快送达对方，如果对方处于离线状态，则通过<code>推送服务</code>把消息异步投递过去，不过离线的推送功能不在本小册的范围内，所以我们重点介绍消息的<code>可靠投递</code>逻辑。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099b99722d4a4afb8ac167ddfc2c5aec~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="chapter20.png"></p><h3 id="理论基础" tabindex="-1">理论基础 ​</h3><p>在实现消息可靠性投递之前，我们首先了解下在分布式系统中，数据同步方面的一些基本的理论及实现原理，当然这里不是介绍CAP理论。</p><p>实际上在前面<strong>通信协议之状态</strong>一章协议的分解图中，<strong>传输层</strong>的两种协议<code>UDP</code>与<code>TCP</code>，它们投递消息的<code>实现原理</code>就是我们可以借鉴的对象，比如UDP就只发送一次而不管接收方是否收到消息，而TCP则保证消息投递的可靠性，当然在这里我不准备深入介绍TCP是如何保证可靠性的，相信读者或多或少也了解过。因此我们回到做后台开发的读者比较了解的一个领域<code>消息中间件</code>，如Kafka，它定义了消息投递的几种情况：</p><ul><li><code>最多一次</code>（At-most Once）</li><li><code>最少一次</code>（At-least Once）</li><li><code>正好一次</code>（Exactly Once）</li></ul><blockquote><p>而IM的消息投递可靠性的道理与之相同，我们来分析一下它们的含义及逻辑。</p></blockquote><h4 id="最多一次" tabindex="-1">最多一次 ​</h4><p>这个是最简单的实现方式，在上一章节中，如果没有其它逻辑，实际上它就是一个<code>At-most Once</code>的逻辑，也就是像UDP一样把消息发送过去就完事了。它的优点就是实现简单，缺点嘛~</p><ul><li>就是会被产品经理da死。。。</li></ul><h4 id="最少一次" tabindex="-1">最少一次 ​</h4><p>最少一次即保证消息至少投递一次到接收方，也就是说接收方可能收到重复的消息。要实现这一点就需要SDK给服务端一个ACK，告诉消息已经接收到，如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3396fb6d01c47f1883512933fe1a0f6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="At_least_Once.png"></p><p>如果接收方在<code>第2步</code>完成之后发生异常断开了连接，ACK消息也就无法送达给服务端，<strong>因此服务端会认为接收方没有收到这条消息</strong>，当接收方再次重连登录之后，就会把这条消息发送过去。可以看到，在这种情况下，<strong>接收方业务层就会接收到重复的消息</strong>。</p><blockquote><p>是不是与TCP中的消息<code>AC</code>K和<code>重传</code>相似！</p></blockquote><h4 id="正好一次" tabindex="-1">正好一次 ​</h4><p>从分布式系统的理论上来说，Exactly-once投递是不可能的，它的代价太高无法实际应用到生产环境，也就是说无法达到上图中的<code>第1步</code>和<code>第2步</code><strong>同时只执行一次</strong>。但是我们可以通过SDK的<code>幂等</code>处理，对上层业务来说达到同样的效果。</p><blockquote><p><strong>幂等</strong>（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个<strong>幂等</strong>操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c514be27cd452cb106299a4be4c52b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="exactly_once.png"></p><p>在SDK端，我们把消息通过数据库的<code>主键唯一的特性</code>，也能达到<strong>幂等</strong>的效果。还是上面的逻辑，当第一次收到消息之后，SDK就会把它写入本地数据库，成功之后就上报给业务层；如果<strong>相同ID</strong>的消息第二次发送到SDK端，此时再插入数据就会主键冲突报错，也就无需通知给上层业务了，因此对业务层来说服务端消息的投递就是<strong>Exactly-once</strong>。</p><blockquote><p>搞明白了以上原理，我们正式进入主题！</p></blockquote><h3 id="可靠投递" tabindex="-1">可靠投递 ​</h3><p>消息的<code>可靠投递</code>是IM系统的核心基础，也是一个难点。读者需要注意的是与<strong>消息中间件MQ</strong>的差异，虽然同样有消息的生产与消费，看似相同，但是在消息中间件中通常消息的<strong>生产与消费是异步的</strong>。如下是一个大致的示意图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398537faad7a4549af3d659c34bb04af~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="mq_flow.png"></p><p>如果消费者一直不消费，那么队列中的读位置与队列尾部的偏移量会非常大；当消费者进程启动之后，如果它不想丢掉消息，只能慢慢的依次消费，当然通常情况下使用消息中间件的业务场景也不要求很高的即时性。但是在IM中确强调消息的<code>即时性</code>，IM中的在线消息是立即<code>Push</code>给接收方。如果接收方不在线，当它再次上线时，则要在非常短的时间内同步完<strong>离线消息</strong>。</p><blockquote><p>因此在聊天场景中，单一用户的离线消息的要么<code>有数量限制</code>，要么离线消息会有一个<code>存活时间</code>，超出范围的消息将被丢弃。</p></blockquote><p>回到本小册的IM实战项目中，我们也是基于<code>正好一次</code>（Exactly Once）来设计消息的投递逻辑，<strong>但是这需要SDK的配合</strong>。我为什么强调<strong>需要SDK的配合</strong>这一点呢，因为在本小册的web端SDK实战中没有准备开发本地存储逻辑。即使有，用户更换一个浏览器也就相当于没有了，而且更换浏览器的的代价相对于App端来说太小，我们无法要求用户总是使用同一个浏览器或者不清理缓存。当然了，在web端支持这个功能也可以很大概率减少出现重复的未读消息的概率。</p><blockquote><p>接下来，我们看看在IM系统中，在线与离线状态下消息的投递逻辑。</p></blockquote><h4 id="在线逻辑" tabindex="-1">在线逻辑 ​</h4><h5 id="接收端" tabindex="-1">接收端 ​</h5><p>在前一章节，发送方投递的消息到达Chat服务之后，<strong>首先就是写入离线队列，而不管接收方是否在线</strong>。假如服务端认为接收方“在线”就不存储消息，一种可能的情况就是接收方处于异常离线但服务端还未检测到的状态，此时消息是无法送达到接收方的；或者说接<strong>收方收到的消息之后<code>crash</code>了</strong>，这些情况都会导致消息<strong>投递失败</strong>。</p><p>因此，通常消息的投递成功一定是基于接收方主动确认告知服务端，如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7abdd9b20c354f619d4d7675856151ea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="user_talk_offline_diagram1.png"></p><p>从消息的发送到消息的成功投递一共有四步：</p><ul><li><code>发送方</code>把消息投递到服务端，并存储到<code>接收方</code>的离线队列。</li><li>消息被投递给<code>接收方</code>，SDK把消息写入本地数据库（如sqlite）。</li><li><code>接收方</code>回复一条ACK消息给服务端，服务端把消息设置为已读。</li></ul><p>如果接收方没有回复ACK，那么这条消息就成了离线消息，在接收方重连登陆之后，离线同步逻辑会把消息同步到SDK端。</p><blockquote><p>我们接着分析这个逻辑，还有优化的空间吗？</p></blockquote><p>在聊天场景下，通常消息的收发是连续性的，在一断时间用户非常活跃，如果每收到一条消息就回复一条ACK，在一定程度是有点浪费服务端资源，因此SDK端收到消息之后可以间隔一段时间之后，一次性回复一条ACK消息。如下图所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64afe1fd28cd4bf2808d2103a6899d50~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="user_talk_offline_diagram2.png"></p><p>在上图中，用户B的SDK端收到消息a、b之后没有立刻回复ACK消息，而是在delay一段时间之后，通过一个ACK的批量操作，告诉服务端<code>a、b、c、d</code>四条消息已经接收完成，如果此时用户B断线重连进入系统，这四条消息是<code>不会当作离线消息</code>同步过来的。</p><h5 id="发送端" tabindex="-1">发送端 ​</h5><p>在上一章节，相信一些细心的读者已经看出来，<code>消息的发送成功的标志</code>就是消息持久化到了服务端数据库中。<strong>而无需关心这条消息是否投递到了接收方</strong>，这在一定程序上是对逻辑的解耦，既可以保证消息的可靠性，也大大简化了流程，越是简单的逻辑稳定性就越高。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47875a83ae94c3c887fd99d951b9d14~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="send_message_confirm.png"></p><p>如果SDK在一段时间内没有收到服务端的Resp消息，或者收到的Resp中返回的status状态不是Success，SDK就需要做出对应的反应，主要有如下三种：</p><ul><li><code>消息重发</code></li><li><code>断线重连</code></li><li><code>错误上报给业务层</code></li></ul><p>而这个判断的依据则是根据返回的<code>status</code>与<code>定义的规则</code>来决定的，我们在介绍SDK逻辑时再详细介绍。</p><h4 id="离线逻辑" tabindex="-1">离线逻辑 ​</h4><p>介绍完了在线状态的消息处理过程，接下来一起来了解下离线逻辑。当一个用户离线之后，再次登陆到服务端时，就需要同步离线消息，也就是把下线的时间段内其它人发送过来的消息同步下来。而同步的方式有推（Push）和拉（Pull）两种。</p><ul><li>推（Push）：指用户登陆之后，服务端主动把离线消息Push过去。</li><li>拉（Pull）：指用户登陆之后，通过接口或者长连指令主动拉离线消息。</li></ul><p>Push与Pull的区别在于谁主动发起。在离线消息逻辑中，为了尽快同步完所有离线消息，消息被批量打成一个包发送给接收方，不会像在线推送一样一条一条。如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8faa7ef2a245d294ceb65f33733875~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="offline_pull_push.png"></p><p>上图中的<code>结束条件</code>指SDK端确认消息已经同步完，<code>但是只要有一条消息返回，最后一次的ACK就不能少</code>。可以看到除了出发点不同，它们之后的逻辑就比较相同的，但是它们各有优缺点：</p><ul><li>Push方式对SDK端的逻辑更简单，但是它不太灵活，开始之后SDK就无法停止，直到消息全部同步完。比如在非常活跃的群特别多的App场景下，用户离线一周之后可能会有1w+的离线消息生产，<strong>假设每次我们推送100条消息，就要推送100次，如果加上每个轮回中SDK存储本地数据库所占的时间</strong>，就会导致APP一直阻塞在登录状态中。</li><li>Pull方式对SDK来说复杂一点，但是它更灵活。比如<strong>Pull的方式不一定走Chat通信服务，也可以走Http接口服务</strong>。</li></ul><blockquote><p><strong>在本实战项目KIM中</strong>，我们采用<code>Pull</code>拉的方式处理离线逻辑。</p></blockquote><h3 id="逻辑优化" tabindex="-1">逻辑优化 ​</h3><h4 id="请求合并" tabindex="-1">请求合并 ​</h4><p>首先，在上面的Pull流程中，每个轮次的<strong>消息同步</strong>都有两次请求Request和Ack，因此我们考虑把它们合并为一次请求。如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/573de9977721439aa12a32c53001d38d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="offline_pull_optimized_1.png"></p><p>在上面的流程中，我们在请求离线消息时，会把<code>上一轮</code>要<strong>确认的消息ID</strong>一并带过去。比如请求包参数如下：</p><blockquote><p>Requet offline message:</p></blockquote><table tabindex="0"><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>account</td><td>string</td><td>接收方账号</td></tr><tr><td>ack_message_ids</td><td>[]int64</td><td>待确认的消息ID</td></tr></tbody></table><p><code>第一次请求时，可以把ack_message_ids传空</code>，只当是一次GET操作。</p><h4 id="ack消息id合并" tabindex="-1">ACK消息ID合并 ​</h4><p>在上面的逻辑中，我们存储的离线消息是基于<strong>状态位</strong>来表示的，我们以mysql表为例来说明这个问题，假设如下就是离线消息表，我们设置一个<code>delivered</code>字段来表示<strong>消息是否已确认被投递到了接收方</strong>：</p><table tabindex="0"><thead><tr><th>message_id</th><th><code>receiver</code></th><th>sender</th><th>type</th><th>body</th><th>delivered</th></tr></thead><tbody><tr><td>11111</td><td>user_b</td><td>user_a</td><td>text</td><td>a</td><td>1</td></tr><tr><td>11112</td><td>user_b</td><td>user_a</td><td>text</td><td>b</td><td>0</td></tr><tr><td>11113</td><td>user_b</td><td>user_a</td><td>text</td><td>c</td><td>0</td></tr><tr><td>11114</td><td>user_b</td><td>user_a</td><td>text</td><td>d</td><td>0</td></tr></tbody></table><p>如上是user_a给user_b发送的四条消息，其中消息<strong>b、c和d</strong>就是离线消息，还未被ACK确认。因此下次<code>同步离线消息时，必须更新消息ID为11112、11113和11114这三条消息</code>，而数据库的更新操作也是一个较<code>耗时</code>的IO操作，这对一个高频的消息收发IM系统的性能影响是非常大的。</p><p>因此我们通过给每个用户在服务端添加一个<code>读索引</code>，而同时与SDK约定一条规则，<code>即在ACK时，只需要给一条发送时间最大的消息ID即可</code>。这个逻辑同样适用于<code>在线状态</code>的ACK，这个逻辑是基于我们假设<strong>用户确认收到了一条消息，那么这条消息之前的所有消息就一定收到了</strong>！ 虽然在分布式系统中很难保证消息的绝对顺序。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19352d77e8464a92b4002afdfe82cb4f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="user_talk_offline_diagram3.png"></p><p>因此，我们删除上表中的<code>delivered</code>字段，而使用下面的索引<code>latest_ack_msg_id</code>代替。这样每次消息Ack时无论有多少条消息，<strong>只需要更新一条记录即可</strong>。在本KIM项目中，为了近一步提高它的更新速度，我们把这个索引保存在了缓存Redis中。如下是一个读索引的示意结构：</p><table tabindex="0"><thead><tr><th>receiver</th><th><code>latest_ack_msg_id</code></th></tr></thead><tbody><tr><td>user_b</td><td>11112</td></tr></tbody></table><p>使用读索引的另一个好处就是SDK登录之后，第一次请求离线消息时，可以把<strong>本地数据库</strong>中<code>最后一条消息的ID</code>作为<code>latest_ack_msg_id</code>的值，这样可以近一步解决本地SDK的读索引与服务端读索引不一致导致的消息重复同步。比如本地的最大读消息索引为<code>18</code>，因为SDK<strong>最后一批消息</strong>还没有ACK给服务端就离线了，此时服务端的读了索引为<code>10</code>，那么第一次同步消息时，就可以<code>减少8条消息</code>的同步。</p><h4 id="索引与内容分离" tabindex="-1">索引与内容分离 ​</h4><p>由于我们设计的是Paas即时通讯云服务，因此在考虑时，就不能把微信这种用户粘性非常强的App当作示例来设计离线消息逻辑。</p><p>实际情况可能是，用户离线几天之后，打开App登录时，会有1w+（大群较多）以上的消息需要同步，这会导致程序阻塞在消息同步过程中；而且不同步离线也不行，除非逻辑上设置一个<code>很小的离线消息上限</code>，比如1k。否则，如果一部分离线消息没有同步，<code>读索引</code>跳过了它们，之后就不会把它们当成离线消息同步了。</p><p>在本实战项目<code>KIM</code>中，我们解决这个问题的办法就是把<code>消息的索引</code>与<code>消息的内容</code>分开。因为索引的体积非常小，而且体积非常稳定的，<strong>不像消息内容的大小受用户输入的影响</strong>，因此可以在一次请求中<code>返回大量索引</code>，同步完索引之后，登录就完成了。在客户端，当用户点击会话列表，进入某个单聊或者群聊的会话中时，就可以根据<strong>已经下载的索引</strong>动态加载消息内容。如下图简单的流程图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a6441faaa424c41b10d8d6d67f73217~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="load_offline_index_flow.png"></p><p>可以看到，一个消息被分为两部分，分别在两个不同的逻辑中处理。</p><ul><li>消息索引</li></ul><table tabindex="0"><thead><tr><th>message_id</th><th>receiver</th><th>sender</th><th>sendTime</th></tr></thead><tbody><tr><td>11111</td><td>user_b</td><td>user_a</td><td>1232354345</td></tr><tr><td>11112</td><td>user_b</td><td>user_a</td><td>1234234345</td></tr></tbody></table><ul><li>消息内容</li></ul><table tabindex="0"><thead><tr><th>message_id</th><th>type</th><th>body</th><th>extra</th></tr></thead><tbody><tr><td>11111</td><td>text</td><td>hello</td><td></td></tr><tr><td>11112</td><td>text</td><td>world</td><td></td></tr></tbody></table><blockquote><p><code>以上的所有的表结构只是为了说明逻辑，不代表最终结果。</code></p></blockquote><h3 id="最后总结" tabindex="-1">最后总结 ​</h3><p>本章我们从分布式系统中的数据同步的理论开始，详细解决了在IM中消息投递过程中在线与离线的核心逻辑。在下一章节，我们将详细介绍消息的存储逻辑，即<code>读扩散</code>or<code>写扩散</code>情况下的如何设计存储；并且实现<code>消息存储</code>、<code>消息ACK</code>与<code>离线消息同步</code>等逻辑。</p><p><strong>本章完！</strong></p>',85),s=[p];function r(a,n,i,l,b,g){return d(),e("div",null,s)}const k=t(c,[["render",r]]);export{m as __pageData,k as default};
