import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as n}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/React 进阶实践指南/33 V18特性篇-useMutableSource（已被取缔）.md","filePath":"mdviewer/XIAOCE/React 进阶实践指南/33 V18特性篇-useMutableSource（已被取缔）.md"}'),t={name:"mdviewer/XIAOCE/React 进阶实践指南/33 V18特性篇-useMutableSource（已被取缔）.md"},e=n(`<h2 id="过时的-react-api" tabindex="-1">过时的 React API ​</h2><h3 id="一-前言" tabindex="-1">一 前言 ​</h3><p><code>useMutableSource</code> 最早的 RFC 提案在 2020年 2 月份就开始了。在 React 18 中它将作为新特性出现。用一段提案中的描述来概括 <code>useMutableSource</code>。</p><blockquote><p>useMutableSource 能够让 React 组件在 Concurrent Mode 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。</p></blockquote><p>说起外部数据源就要从 state 和更新说起 ，无论是 React 还是 Vue 这种传统 UI 框架中，虽然它们都采用虚拟 DOM 方式，但是还是不能够把更新单元委托到虚拟 DOM 身上来，所以更新的最小粒度还是在组件层面上，由组件统一管理数据 state，并参与调度更新。</p><p>回到我们的主角 React 上，既然由组件 component 管控着状态 state。那么在 v17 和之前的版本，React 想要视图上的更新，那么只能通过更改内部数据 state 。纵览 React 的几种更新方式，无一离不开自身 state 。先来看一下 React 的几种更新模式。</p><ul><li>组件本身改变 state 。函数 <code>useState</code> | <code>useReducer</code> ，类组件 <code>setState</code> | <code>forceUpdate</code> 。</li><li><code>props</code> 改变，由组件更新带来的子组件的更新。</li><li><code>context</code> 更新，并且该组件消费了当前 <code>context</code> 。</li></ul><p>无论是上面哪种方式，本质上都是 state 的变化。</p><ul><li><code>props</code> 改变来源于父级组件的 <code>state</code> 变化。</li><li><code>context</code> 变化来源于 Provider 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。</li></ul><p>从上面可以概括出：state和视图更新的关系 <code>Model =&gt; View</code> 。但是 state 仅限于组件内部的数据，如果 state 来源于外部（脱离组件层面）。那么如何完成外部数据源转换成内部状态， 并且数据源变化，组件重新 render 呢？</p><p>常规模式下，先把外部数据 external Data 通过 selector 选择器把组件需要的数据映射到 state | props 上。这算是完成了一步，接下来还需要 subscribe 订阅外部数据源的变化，如果发生变化，那么还需要自身去强制更新 forceUpdate 。下面两幅图表示数据注入和数据订阅更新。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0734aca032e046d58d9c263b6d3d5cb3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="1.jpg" loading="lazy"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd8b70d275ad4f8aa84f18f4029960ea~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="2.jpg" loading="lazy"></p><p>典型的外部数据源就是 redux 中的 store ，redux 是如何把 Store 中的 state ，安全的变成组件的 state 的。</p><p>或许我可以用一段代码来表示从 react-redux 中 state 改变到视图更新的流程。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer,initState)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setReduxState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({})</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> contextValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 订阅 store 变化 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             /* 用选择器选择订阅 state */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">             /* 如果发生变化  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifHasChange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state,value)){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                 setReduxState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },[ store ])    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但是例子中代码，没有实际意义，也不是源代码，我这里就是让大家清晰地了解流程。redux 和 react 本质上是这样工作的。</p><ul><li>通过 store.subscribe 来订阅 state 变化，但是本质上要比代码片段中复杂的多，通过 selector （选择器）找到组件需要的 state。 我在这里先解释一下<strong>selector</strong>，因为在业务组件往往不需要整个 store 中的 state 全部数据，而是仅仅需要下面的部分状态，这个时候就需要从 state 中选择‘有用的’，并且和 props 合并，细心的同学应该发现，选择器需要和 <code>react-redux</code> 中 connect 第一参数 <code>mapStateToProps</code> 联动。对于细节，无关紧要，因为今天重点是 <code>useMutableSource</code>。</li></ul><p>如上是没有 useMutableSource 的情况，现在用 useMutableSource 不在需要把订阅到更新流程交给组件处理。如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 创建 store */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reducer,initState)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 创建外部数据源 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> externalDataSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( store ,store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() )</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 订阅更新 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 订阅的 state 发生变化，那么组件会更新 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(externalDataSource,selector,subscribe)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>通过 createMutableSource 创建外部数据源，通过 useMutableSource 来使用外部数据源。外部数据源变化，组件自动渲染。</li></ul><p>如上是通过 useMutableSource 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合。接下来让我们全方面认识一下这个 V18 的新特性。</p><h3 id="二-功能介绍" tabindex="-1">二 功能介绍 ​</h3><p>具体功能介绍流程还是参考最新的 RFC， createMutableSource 和 useMutableSource 在一定的程度上，有点像 <code>createContext</code> 和 <code>useContext</code> ，见名知意，就是<strong>创建与使用</strong>。不同的是 context 需要 Provider 去注入内部状态，而今天的主角是注入外部状态。那么首先应该看一下两者如何使用。</p><h4 id="创建" tabindex="-1">创建 ​</h4><p>createMutableSource 创建一个数据源。它有两个参数：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> externalDataSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( store ,store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() )</span></span></code></pre></div><ul><li>第一个参数：就是外部的数据源，比如 redux 中的 store,</li><li>第二个参数：一个函数，函数的返回值作为数据源的版本号，这里需要注意⚠️的是，要保持数据源和数据版本号的一致性，就是数据源变化了，那么数据版本号就要变化，一定程度上遵循 <code>immutable</code> 原则（不可变性）。可以理解为数据版本号是证明数据源唯一性的标示。</li></ul><h4 id="api介绍" tabindex="-1">api介绍 ​</h4><p>useMutableSource 可以使用非传统的数据源。它的功能和 Context API 还有 useSubscription 类似。（没有使用过 useSubscription 的同学，可以了解一下 ）。</p><p>先来看一下 useMutableSource 的基本使用：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source,getSnapShot,subscribe)</span></span></code></pre></div><p>useMutableSource 是一个 hooks ，它有三个参数：</p><ul><li><code>source：MutableSource &lt; Source &gt;</code> 可以理解为带记忆的数据源对象。</li><li><code>getSnapshot：( source : Source ) =&gt; Snapshot</code> ：一个函数，数据源作为函数的参数，获取快照信息，可以理解为 selector ，把外部的数据源的数据过滤，找出想要的数据源。</li><li><code>subscribe: (source: Source, callback: () =&gt; void) =&gt; () =&gt; void</code>：订阅函数，有两个参数，Source 可以理解为 useMutableSource 第一个参数，callback 可以理解为 useMutableSource 第二个参数，当数据源变化的时候，执行快照，获取新的数据。</li></ul><p><strong>useMutableSource 特点</strong></p><p>useMutableSource 和 useSubscription 功能类似：</p><ul><li>两者都需要带有记忆化的‘配置化对象’，从而从外部取值。</li><li>两者都需要一种订阅和取消订阅源的方法 <code>subscribe</code>。</li></ul><p>除此之外 useMutableSource 还有一些特点：</p><ul><li>useMutableSource 需要源作为显式参数。也就是需要把数据源对象作为第一个参数传入。</li><li>useMutableSource 用 getSnapshot 读取的数据，是不可变的。</li></ul><p><strong>关于 MutableSource 版本号</strong></p><p><code>useMutableSource</code> 会追踪 MutableSource 的版本号，然后读取数据，所以如果两者不一致，可能会造成读取异常的情况。useMutableSource 会检查版本号：</p><ul><li>在第一次组件挂载的时候，读取版本号。</li><li>在组件 rerender 的时候，确保版本号一致，然后在读取数据。不然会造成错误发生。</li><li>确保数据源和版本号的一致性。</li></ul><p><strong>设计规范</strong></p><p>当通过 getSnapshot 读取外部数据源的时候，返回的 value 应该是不可变的。</p><ul><li>✅ 正确写法：getSnapshot: source =&gt; Array.from(source.friendIDs)</li><li>❌ 错误写法：getSnapshot: source =&gt; source.friendIDs</li></ul><p>数据源必须有一个全局的版本号，这个版本号代表整个数据源：</p><ul><li>✅ 正确写法：getVersion: () =&gt; source.version</li><li>❌ 错误写法：getVersion: () =&gt; source.user.version</li></ul><p>接下来参考 github 上的例子，我讲一下具体怎么使用：</p><h4 id="例子一" tabindex="-1">例子一 ​</h4><p><strong>例子一：订阅 history 模式下路由变化</strong></p><p>比如有一个场景就是在非人为情况下，订阅路由变化，展示对应的 <code>location.pathname</code>，看一下是如何使用 useMutableSource 处理的。在这种场景下，外部数据源就是 location 信息。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过 createMutableSource 创建一个外部数据源。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 数据源对象为 window。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> locationSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.location.href</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSnapshot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.location.pathname</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 订阅函数。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //通过 popstate 监听 history 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;popstate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   //取消监听</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;popstate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, callback);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Example</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 通过 useMutableSource，把数据源对象，快照函数，订阅函数传入，形成 pathName。  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> pathName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(locationSource, getSnapshot, subscribe);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>来描绘一下流程：</p><ul><li>首先通过 <code>createMutableSource</code> 创建一个数据源对象，该数据源对象为 window。 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。</li><li>获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。</li><li>通过 <code>popstate</code> 监听 <code>history</code> 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。</li><li>通过 <code>useMutableSource</code> ，把数据源对象，快照函数，订阅函数传入，形成 <code>pathName</code> 。</li></ul><p>可能这个例子🌰，不足以让你清楚 useMutableSource 的作用，我们再举一个例子看一下 useMutableSource 如何和 redux 契合使用的。</p><h4 id="例子二" tabindex="-1">例子二 ​</h4><p><strong>例子二：redux 中 <code>useMutableSource</code> 使用</strong></p><p>redux 可以通过 useMutableSource 编写自定义 hooks —— <code>useSelector</code>，useSelector 可以读取数据源的状态，当数据源改变的时候，重新执行快照获取状态，做到订阅更新。我们看一下 useSelector 是如何实现的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mutableSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  reduxStore, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 redux 的 store 作为数据源。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // state 是不可变的，可以作为数据源的版本号</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reduxStore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过创建 context 保存数据源 mutableSource。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MutableSourceContext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutableSource);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 订阅 store 变化。store 变化，执行 getSnapshot</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义 hooks useSelector 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useSelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mutableSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MutableSourceContext);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 用 useCallback 让 getSnapshot 变成有记忆的。 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getSnapshot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()), [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    selector</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 最后本质上用的是 useMutableSource 订阅 state 变化。  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutableSource, getSnapshot, subscribe);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>大致流程是这样的：</p><ul><li>将 redux 的 store 作为数据源对象 <code>mutableSource</code> 。 state 是不可变的，可以作为数据源的版本号。</li><li>通过创建 context 保存数据源对象 <code>mutableSource</code>。</li><li>声明订阅函数，订阅 store 变化。store 变化，执行 <code>getSnapshot</code> 。</li><li>自定义 hooks <code>useSelector</code> 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 用 <code>useCallback</code> 让 getSnapshot 变成有记忆的。</li><li>最后本质上用的是 useMutableSource 订阅外部 state 变化。</li></ul><p><strong>注意问题</strong></p><ul><li>在创建 getSnapshot 的时候，需要将 getSnapshot 记忆化处理，就像上述流程中的 useCallback 处理 getSnapshot 一样，如果不记忆处理，那么会让组件频繁渲染。</li><li>在最新的 react-redux 源码中，已经使用新的 api，订阅外部数据源，不过不是 <code>useMutableSource</code> 而是 <code>useSyncExternalStore</code>，具体因为 <code>useMutableSource</code> 没有提供内置的 selectorAPI，需要每一次当选择器变化时候重新订阅 store，如果没有 useCallback 等 api 记忆化处理，那么将重新订阅。具体内容请参考 useMutableSource → useSyncExternalStore。</li></ul><h3 id="三-实践" tabindex="-1">三 实践 ​</h3><p>接下来我用一个例子来具体实践一下 <code>createMutableSource</code>，让大家更清晰流程。</p><p>这里还是采用 redux 和 createMutableSource 实现外部数据源的引用。这里使用的是 <code>18.0.0-alpha</code> 版本的 <code>react</code> 和 <code>react-dom</code> 。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a000b3baac184fe9903700ad51e03be7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="3.jpg" loading="lazy"></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  React , {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    unstable_useMutableSource </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> useMutableSource,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    unstable_createMutableSource </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> createMutableSource</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { combineReducers , createStore  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;redux&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* number Reducer */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> numberReducer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (action.type){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ADD&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;DEL&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 注册reducer */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rootReducer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> combineReducers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ number:numberReducer  })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 合成Store */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rootReducer,{ number: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 注册外部数据源 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dataSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( Store ,() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 订阅外部数据源 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dataSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unSubScribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataSource.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callback)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> unSubScribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* TODO: 情况一 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 获取数据快照 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> shotSnop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()}),[])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /*  hooks:使用 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dataSource,shotSnop,subscribe)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 拥抱 React 18 🎉🎉🎉 &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        赞：{data.number} &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">br</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ type:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ADD&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })} &gt;点赞&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>第一部分用 <code>combineReducers</code> 和 <code>createStore</code> 创建 redux Store 的过程。 重点是第二部分：</p><ul><li>首先通过 createMutableSource 创建数据源，Store 为数据源，<code>data.getState()</code> 作为版本号。</li><li>第二点就是快照信息，这里的快照就是 store 中的 state。所以在 <code>shotSnop</code> 还是通过 getState 获取状态，正常情况下 shotSnop 应该作为 <code>Selector</code>，这里把所有的 state 都映射出来了。</li><li>第三就是通过 <code>useMutableSource</code> 把数据源，快照，订阅函数传入，得到的 data 就是引用的外部数据源了。</li></ul><p>接下来让我们看一下效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81ad31834d0941859cf767d22d685c6b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="4.gif" loading="lazy"></p><h3 id="四-原理分析" tabindex="-1">四 原理分析 ​</h3><p>useMutableSource 已经在 React v18 的规划之中了，那么它的实现原理以及细节，在 V18 正式推出之前可以还会有调整，</p><h4 id="_1-createmutablesource" tabindex="-1">1 createMutableSource ​</h4><blockquote><p>react/src/ReactMutableSource.js -&gt; createMutableSource</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> mutableSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _getVersion: getVersion,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _source: source,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _workInProgressVersionPrimary: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        _workInProgressVersionSecondary: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mutableSource</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>createMutableSource 的原理非常简单，和 <code>createContext</code> ， <code>createRef</code> 类似， 就是创建一个 <code>createMutableSource</code> 对象，</p><h4 id="_2-usemutablesource" tabindex="-1">2 useMutableSource ​</h4><p>对于 useMutableSource 原理也没有那么玄乎，原来是由开发者自己把外部数据源注入到 state 中，然后写订阅函数。 useMutableSource 的原理就是把开发者该做的事，自己做了😂😂😂，这样省着开发者去写相关的代码了。本质上就是 <strong>useState + useEffect</strong> ：</p><ul><li>useState 负责更新。</li><li>useEffect 负责订阅。</li></ul><p>然后来看一下原理。</p><blockquote><p>react-reconciler/src/ReactFiberHooks.new.js -&gt; useMutableSource</p></blockquote><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getSnapshot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 获取版本号 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getVersion</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source._getVersion;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source._source);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 用 useState 保存当前 Snapshot，触发更新。 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [currentSnapshot, setSnapshot] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dispatcher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">       readFromUnsubscribedMutableSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, source, getSnapshot),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dispatcher.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 包装函数  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleChange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            /* 触发更新 */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setSnapshot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 订阅更新 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unsubscribe</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source._source, handleChange);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* 取消订阅 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsubscribe;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },[source, subscribe])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上述代码中保留了最核心的逻辑：</p><ul><li>首先通过 <code>getVersion</code> 获取数据源版本号，用 <code>useState</code> 保存当前 Snapshot，setSnapshot 用于触发更新。</li><li>在 <code>useEffect</code> 中，进行订阅，绑定的是包装好的 handleChange 函数，里面调用 setSnapshot 真正的更新组件。</li><li>所以 useMutableSource 本质上还是 useState 。</li></ul><h3 id="五-总结" tabindex="-1">五 总结 ​</h3><p>今天讲了 useMutableSource 的背景，用法，以及原理。希望阅读的同学可以克隆一下 React v18 的新版本，尝试一下新特性，将对理解 useMutableSource 很有帮助。下一章我们将继续围绕 React v18 展开。</p>`,88),l=[e];function h(p,k,r,d,E,c){return a(),i("div",null,l)}const b=s(t,[["render",h]]);export{F as __pageData,b as default};
