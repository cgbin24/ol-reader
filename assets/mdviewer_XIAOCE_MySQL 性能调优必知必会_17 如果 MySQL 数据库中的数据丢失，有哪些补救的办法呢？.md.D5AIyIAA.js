import{_ as o}from"./app.BdTF1atn.js";import{j as e,i as c,Z as d}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const L=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/MySQL 性能调优必知必会/17 如果 MySQL 数据库中的数据丢失，有哪些补救的办法呢？.md","filePath":"mdviewer/XIAOCE/MySQL 性能调优必知必会/17 如果 MySQL 数据库中的数据丢失，有哪些补救的办法呢？.md"}'),l={name:"mdviewer/XIAOCE/MySQL 性能调优必知必会/17 如果 MySQL 数据库中的数据丢失，有哪些补救的办法呢？.md"},r=d('<p>我以前在企业面试的时候，我经常喜欢问一些求职者关于 MySQL 数据库相关的问题，其中最典型的就是关于 MySQL 数据库数据安全的问题。</p><p>例如：如何才能保证 MySQL 数据库的数据安全？MySQL 数据库如果发生数据丢失可能会发生在什么地方？如果 MySQL 数据库出现了数据丢失该如何挽救？</p><p>问这些问题的主要目的就是考验求职者的生产经验；但是就我面试的过程而言，能够完整答出来的求职者微乎其微。</p><p>出现这种情况主要是因为大多数求职者对于 MySQL 数据库底层数据存储的运行机制了解得不够清楚，那么今天我们就来针对于上述的几个问题跟大家详细讨论一下 MySQL 数据库的底层存储运行机制。</p><h3 id="mysql-数据库在什么情况下可能会发生数据丢失" tabindex="-1">MySQL 数据库在什么情况下可能会发生数据丢失 ​</h3><p>在介绍 MySQL 数据库在什么情况下可能会丢失数据之前，我们首先回顾一下写入一条数据到 MySQL 数据库中所经历的模块，具体如下。</p><ul><li>第一个模块：将修改的数据逻辑保存在 <code>change buffer</code> 之中。</li><li>第二个模块：将修改的数据保存在 <code>binlog cache</code> 之中。</li><li>第三个模块：将修改的数据保存在 <code>redo log</code> 之中。</li></ul><p>在这三个模块中，<code>change buffer</code> 是用来保存修改数据的逻辑的，在修改之后，通过 merge 的方式写入磁盘。具体我们可以参考 <strong>第 7 篇</strong> 文章 和 <strong>第 13 篇</strong> 文章。</p><p>在这个模块中，有没有可能发生数据丢失呢？其实微乎其微，这主要是因为 MySQL 数据库为了防止数据丢失而增加了 <code>redo log</code> 这个模块，其主要的作用就是防止数据丢失。那么，我们就一起来聊一聊 <code>redo log</code> 是怎么保存数据的。</p><p><code>redo log</code> 主要分为两个部分，分别是 <code>redo log</code> 和 <code>redo log buffer</code> 两个部分。<code>redo log</code> 和 <code>redo log buffer</code> 的功能我们之前多次说过，这里不再赘述。下面我们主要介绍 <code>redo log</code> 是怎么保存数据的。</p><p>当一条数据写入数据库之前，为了防止数据丢失，首先会将该条数据保存在 <code>redo log buffer</code> 之中，然后再保存在 <code>redo log</code> 之中，以便当数据库宕机之时作数据恢复使用。</p><p>那么这个时候我们就要问，在这个过程中 <code>redo log</code> 有没有可能会发生数据丢失呢？</p><p>这是有可能的。假如一个事务在执行一半的时候突然 MySQL 数据库宕机，此时 <code>redo log buffer</code> 中的所有数据将会全部丢失，不过一般这种情况只会发生在事务未提交的情况下，所有数据丢失也影响不大。</p><p>此时，我相信你会问，如果恰好在事务提交之时，MySQL 数据库发生宕机会不会丢失数据呢？</p><p>显然，这也是有可能的。下面我们根据 MySQL 数据库保存 <code>redo log buffer</code> 中的数据来分析丢失数据的可能。</p><p>在 MySQL 数据库中，<code>redo log buffer</code> 有三种保存数据的状态，分别是：</p><blockquote><p>注意：系统磁盘也是有缓存的，通常我们称之为：page cacge。</p></blockquote><ul><li><code>redo log buffer</code> 将数据保存在 MySQL 数据库的内存中，也就是 InnoDB 存储引擎的 buffer pool 之中。这其实跟上述的情况一致，保存的是未提交的数据，此时如果 MySQL 发生宕机，丢失的是未提交的事务信息，对于 MySQL 数据库整体而言，没有大的影响。</li><li><code>redo log buffer</code> 将数据保存在 <code>page cache</code> 之中，也就是磁盘缓存之中。此时 MySQL 中的事务已经提交，假设恰巧运行 MySQL 数据库的服务器在此时发生宕机，那么很显然已经提交的事务数据就会发生丢失。在这种情况下发生的数据丢失是无法恢复的。</li><li><code>redo log buffer</code> 将数据保存在磁盘之中，这种情况下一般只有磁盘不发生异常，是不会发生数据丢失的。</li></ul><p>MySQL 针对于<code>redo log buffer</code>保存数据的三种状态又提供了名为<code>innodb_flush_log_at_trx_commit</code>的参数，这个参数有三个值，最主要的功能是告诉 MySQL 该将 <code>redo log buffer</code> 中的数据保存在哪里，具体如下：</p><ul><li>当该参数的值设置为 <code>0</code> 时，<code>redo log buffer</code> 将会把所有的数据保存在 <code>buffer pool</code> 之中；也就是全部保存在内存之中，此时性能是最好的，但是一旦数据库发生了重启，<code>redo log buffer</code> 中的数据也就随即全部丢失。</li><li>当该参数的值设置为 <code>1</code> 时，<code>redo log buffer</code> 将会把所有的数据直接保存在磁盘之中，此时数据是最安全的，但是性能却是最差的。</li><li>当该参数的值设置为 <code>2</code> 时，<code>redo log buffer</code> 将会把所有的数据保存在 <code>page cache</code> 之中；也就是说会将数据全部保存在磁盘缓存之中，此时性能跟设置为 <code>0</code> 时的性能相差无几，但是如果此时部署 MySQL 数据库的服务器发生了宕机，数据也会随即丢失。</li></ul><blockquote><p>注意：在实际的应用中，也并非只有事务发生了提交，才会将数据保存到磁盘之中。还有如下两种情况。</p><ul><li>第一种情况：如果有多个事务并行之时，会将已经保存在 <code>redo log buffer</code> 中的数据全部持久化。</li><li>第二种情况：如果 <code>redo log buffer</code> 占用 InnoDB 存储引擎的 <code>buffer pool</code> 内存空间的一半，MySQL 也会将数据持久化。</li></ul></blockquote><p>上面我们介绍了 <code>redo log</code> 可能会发生数据丢失的场景，下面我们再来了解一下 <code>binlog</code> 中可能发生数据丢失的情况。</p><p>相对于 <code>redo log</code> 来说，<code>binlog</code> 写数据相对简单。</p><p>首先需要说明的是，<code>binlog</code> 每一次写入都是将整个事务同时写入 <code>binlog</code> 文件中，这主要是因为 MySQL 数据库中的事务具有原子性，所以在一个事务未执行完成之前，MySQL 数据库是将其写入 <code>binlog cache</code> 之中。</p><p>其中 <code>binlog cache</code> 是 MySQL 中的一块内存空间，那么此时就带来了一个新的问题，就是如果 <code>binlog cache</code> 的空间不足以承载某一个事务所包含的所有数据时，MySQL 会将该事务中所有的数据全部暂存到磁盘中（此时就会不得已而产生磁盘IO，随即就会导致一定的性能问题）。</p><p>为了解决这个问题，MySQL 数据库为我们提供了一个 <code>binlog_cache_size</code> 参数，这个参数主要是用来设置 <code>binlog cache</code> 的空间大小的。如果当 <code>binlog cache</code> 中的数据大小超过了 <code>binlog_cache_size</code> 设置的大小时，MySQL 会将该事务中所有的数据全部暂存到磁盘中。</p><p>与 <code>redo log</code> 相同的是，<code>binlog cache</code> 也有保存数据的三种状态，并且 MySQL 提供了 <code>sync_binlog</code> 这个参数来控制这种状态。这三种状态分别是：</p><ul><li>当该值等于 <code>0</code> 时，每次事务提交之后，保存在 <code>page cache</code>；</li><li>当该值等于 <code>1</code> 时，每次事务提交之后，保存到磁盘之中；</li><li>当该值等于 <code>N（N &gt; 1）</code> 时，每次事务提交之后，都会保存在 <code>page cache</code> 之中，并且累计 N 次之后写入磁盘。</li></ul><p>于是，我们不难看出，当 <code>N</code> 越大时，相关的性能就会越好；相反，如果在数据提交期间发生了数据库宕机，随即带来的后果就是会丢失保存在 <code>binlog cache</code> 中的数据。</p><h3 id="总结" tabindex="-1">总结 ​</h3><p>今天，我们主要介绍了在 MySQL 数据库运行过程中可能会发生数据丢失的几种情况。</p><p>首先是 <code>redo log</code>，在 <code>redo log</code> 中最可能丢失数据的情况就是当 <code>redo log buffer</code> 中的数据保存在 MySQL 内存之中，也就是当 <code>innodb_flush_log_at_trx_commit</code> 设置成 <code>0</code> 时；所以，为了安全和性能两个方面考虑，建议将其设置成 <code>2</code>， 一般 MySQL 重启，而部署 MySQL 的服务器不会重启。</p><p>其次是 <code>binlog</code>，与 <code>redo log</code>相同的是 <code>binlog</code> 也有三种保存数据的状态，同样为了安全和性能两个方面考虑，我建议你将 <code>sync_binlog</code> 设置成 <code>N</code>。</p><p>在日常的生产环境之中，一般会将 <code>sync_binlog</code> 设置为：<code>100 ~ 1000</code> 之间，具体要看服务器性能，如果服务器的内存有空余，可以将其按需调大。</p>',34),p=[r];function i(_,g,f,n,t,b){return c(),e("div",null,p)}const M=o(l,[["render",i]]);export{L as __pageData,M as default};
