import{_ as s}from"./app.BdTF1atn.js";import{j as i,i as a,Z as e}from"./chunks/@vue.D6nrJjhM.js";/* empty css                          */import"./chunks/@vueuse.ErXst1iV.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/7 使用 Kubernetes 部署访问你的第一个应用.md","filePath":"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/7 使用 Kubernetes 部署访问你的第一个应用.md"}'),p={name:"mdviewer/XIAOCE/从 0 到 1 实现一套 CI & CD 流程/7 使用 Kubernetes 部署访问你的第一个应用.md"},n=e(`<h3 id="changelog" tabindex="-1">Changelog ​</h3><h4 id="_2021-11-10" tabindex="-1">2021.11.10 ​</h4><ol><li><p>Ingress apiVersion的变化。从Kubernetes v1.8+ 开始，apiVersion变更为networking.k8s.io/v1beta1。废弃extensions/v1beta1。</p></li><li><p>结构体的变化。移除了spec.backend字段；backend下的service也会接着细化。主要修改为：</p><ul><li>移除了spec.backend字段</li><li>backend.serviceName，backend.servicePort 更换为了backend.service.name，backend.service.port.number</li></ul></li><li><p>新增了必填字段：pathType。其功能作用是精确匹配和前缀匹配的区别。</p></li></ol><p>例如 <code>path：/wss，pathType: Prefix</code>，等同于<code>path: /wss*</code>。具体详细内容：kubernetes.io/zh/docs/con…</p><ol start="4"><li>更新 ingress 版本到最新 stable 1.0.4 版本，原有的镜像源会失效。我也没找到好的镜像，希望大家如果有挖掘可以提供</li></ol><h3 id="前言" tabindex="-1">前言 ​</h3><p>在上一章，我们部署了一套 <code>Kubernetes</code> 集群环境，这一章我们就来部署自己的第一个 <code>Kubernetes</code> 应用并实现访问。</p><h3 id="声明一份配置清单" tabindex="-1">声明一份配置清单 ​</h3><p>在开始部署前，我们先要声明一份 <code>配置清单</code> ，清单的文件格式为 <code>YAML</code> 文件格式。在 Kubernetes 中，应用部署完全可以通过 <code>YAML</code> 配置清单来进行部署。</p><p>新建一个文件夹，名称叫 <code>deployment</code>，并在文件夹内创建一份 <code>yaml</code> 文件，名称为 <code>v1</code>：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deployment</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> v1.yaml</span></span></code></pre></div><p>接着在配置文件中，写入以下内容：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apiVersion:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apps/v1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kind:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Deployment</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">metadata:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> front-v1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spec:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  selector:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    matchLabels:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      app:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx-v1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  replicas:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  template:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    metadata:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      labels:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        app:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx-v1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    spec:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      containers:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      -</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        image:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry.cn-hangzhou.aliyuncs.com/janlay/k8s_test:v1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        ports:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        -</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> containerPort:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 80</span></span></code></pre></div><p>我们关注下 <code>YAML</code> 文件中的 <code>kind</code> 字段。这是在声明 <code>Kubernetes</code> 的资源类型。在这里，我们的 <code>kind</code> 值为 <code>deployment</code>。那 <code>deployment</code> 又是什么呢？</p><h4 id="什么是-deployment" tabindex="-1">什么是 Deployment ​</h4><p>如果你将 <code>k8s</code> 看作是一个大型机场，那么 <code>deployment</code> 刚好就是机场内的<strong>停机坪</strong>。</p><p>根据飞机的种类进行划分停机坪，不同的停机坪都停着不同类型的飞机。只不过，<code>deployment</code> 要比停机坪还要灵活，随时可以根据剩余的空地大小（服务器剩余资源）和塔台的指令，增大/变小停机坪的空间。<strong>这个“增大变小停机坪空间的动作”，在k8s中就是 <code>deployment</code> 对它下面所属容器数量的扩容/缩小的操作</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b6db0c8e0e4471a077a79bec9f452b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>那么这也就代表，<strong><code>deployment</code>是无状态的，也就不会去负责停机坪中每架飞机之间的通信和组织关系</strong>。只需要根据塔台的指令，维护好飞机的更新和进出指令即可。<strong>这个根据指令维护飞机更新和进出的行为，在k8s中就是 <code>deployment</code> 对他下面的容器版本更新升级，暂停和恢复更新升级的动作</strong>。</p><p>在这里的容器，并不等于 <code>Docker</code> 中的容器。它在K8S中被称为 <code>Pod</code> 。那么 <code>Pod</code> 是什么 ?</p><h4 id="什么是-pod" tabindex="-1">什么是 Pod ​</h4><p>Pod 是 K8S 中最小的可调度单元（可操作/可部署单元），它里面可以包含1个或者多个 Docker 容器。在 Pod 内的所有 Docker 容器，都会共享同一个网络、存储卷、端口映射规则。一个 Pod 拥有一个 IP。</p><p>但这个 IP 会随着Pod的重启，创建，删除等跟着改变，所以不固定且不完全可靠。这也就是 Pod 的 IP 漂移问题。这个问题我们可以使用下面的 Service 去自动映射</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0262415836bb44a38120515430f6148f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>我们经常会把 Pod 和 Docker 搞混，这两者的关系就像是豌豆和豌豆荚，Pod 是一个容器组，里面有很多容器，容器组内共享资源。</p><h4 id="分析配置文件构成" tabindex="-1">分析配置文件构成 ​</h4><p>那么相信大家对 <code>deployment</code> 有大体的概念了。当然，<code>kind</code> 字段不只可以声明 <code>deploymnt</code> ，还可以声明其他的资源类型。重要的我们在后面的章节中都会写到。</p><p>了解了 <code>deployment</code> 是啥后，我们来看看配置清单中的字段都代表的是啥。我们将配置分成三段去进行阅读：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ea48ceb5c743aa9ef9d7d207209d38~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>最上面的第一段声明了当前资源配置的 API 版本，资源类型和资源名称：</p><ul><li>API 配置版本： <code>apps/v1</code></li><li>资源类型：<code>deployment</code></li><li>资源名称：<code>deplyment</code> 的名称叫 <code>front-v1</code></li></ul><p>其中，API 配置版本会随着 K8S 版本迭代和资源类型不同有变化。具体可以看下面这个链接：</p><blockquote><p>该怎么选择 apiVersion 的值: matthewpalmer.net/kubernetes-…</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea51e38cc9b747b3b4cca171728efec5~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/768f7f7282bc4998b1a36d7ccec68a4a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>左边这一段，告诉 <code>deployment</code> 我根据规则匹配相应的 <code>Pod</code> 进行控制和管理。这里使用 <code>matchLabels</code> 字段匹配 <code>Pod</code> 的 <code>label</code> 值。</p><p>右边配置则代表声明一个 Pod 组：</p><ul><li><p>replicas：要创建的 <code>Pod</code> 最大数量。数字类型</p></li><li><p>labels.app：Pod 组的名称</p></li><li><p>spec：组内创建的 Pod 信息</p><ul><li>name：Pod 名称</li><li>image：以什么镜像创建 Pod。这里是 Docker 镜像地址</li><li>ports.containerPort：Pod 内容器映射的端口</li></ul></li></ul><p><strong>这里的镜像，我使用了自己编译的一份 nginx 镜像作为演示，也可以换成你自己的镜像</strong></p><h3 id="启动第一个应用" tabindex="-1">启动第一个应用 ​</h3><p>好了，在我们了解完一份简单的 <code>deployment</code> 的配置清单后，我们就可以使用该清单创建我们的第一个应用。</p><p>在k8s中，我们使用 <code>kubectl apply</code> 来执行一份k8s的配置：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span></span></code></pre></div><p>其中，<code>kubectl apply</code> 代表准备对资源进行配置。 <code>-f</code> 等于 <code>--filename</code>，后面可以跟随多个配置文件。例如：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1-service.yaml</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1-ingress.yaml</span></span></code></pre></div><p>当提示下面文字时，代表配置文件执行成功：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6d70c6bd0d747efa9f15cd5d440ebae~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>如果你想看部署完毕后的 <code>Pod</code> 运行状态，可以使用 <code>kubectl get pod</code> 命令来获取所有 <code>Pod</code> 的信息：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pod</span></span></code></pre></div><p>你会得到一个表格，这是 你自己在 K8S 中部署的所有的Pod。</p><p>其中，name 是Pod的名称；READY 为容器状态，格式为可用容器/所有容器数量；STATUS 为 Pod 的运行状态；RESTARTS 为重启数量；AGE 为 Pod 运行时间；当状态都是 <code>Running</code> 时，代表 Pod 运行正常。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a350995f2ad4a7282680039e5bdeaa7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h4 id="令人费解的无状态" tabindex="-1">令人费解的无状态 ​</h4><p>部署成功了，但怎么去访问具体应用呢？</p><p>前面我们写到， <code>deployment</code> 是无状态的。也就意味着， <code>deployment</code> 并不会对 <code>pod</code> 进行网络通信和分发。想访问服务，有以下两个办法：</p><ol><li>直接访问具体的 <code>Pod</code>：这是一个办法，但是 <code>Pod</code> 太多了，达不到我们自动调度的效果。且 <code>Pod</code> 的 <code>IP</code> 在运行时还会经常进行漂移且不固定（后面会讲到）。</li><li>使用 <code>Service</code> 组织统一的 <code>Pod</code> 访问入口。</li></ol><p>这里我们选择另一种资源类型 —— <code>Service</code> 来进行统一组织 <code>Pod</code> 服务访问</p><h3 id="访问第一个应用" tabindex="-1">访问第一个应用 ​</h3><p>这里我们使用 k8s 的 Service 来组织我们的访问入口。那什么是 Service？</p><h4 id="什么是-service" tabindex="-1">什么是 Service ​</h4><p><code>deployment</code> 是停机坪，那么 <code>Service</code> 则是一块停机坪的统一通信入口。它<strong>负责自动调度和组织deployment中 Pod 的服务访问。由于自动映射 Pod 的IP，同时也解决了 Pod 的IP漂移问题</strong>。</p><p>下面这张图就印证了 <code>Service</code> 的作用。流量会首先进入 VM（主机），随后进入 Service 中，接着 Service 再去将流量调度给匹配的 Pod 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e39fbabcb3a44842baf5ca379d2b4b7c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h4 id="service-的配置" tabindex="-1">Service 的配置 ​</h4><p>同样的，创建一个 <code>Service</code> 也需要一份 <code>YAML</code> 配置清单。一份简单的 <code>Service</code> 的配置如下：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Service</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-service-v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  selector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">nginx-v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">protocol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">TCP</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    port</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    targetPort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">NodePort</span></span></code></pre></div><p>其中比较熟悉的通用字段就不介绍了。有几个特有的字段需要关注下：</p><table tabindex="0"><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td>protocol</td><td>通信类型（TCP/UDP）</td></tr><tr><td>targetPort</td><td>原本 Pod 开放的端口</td></tr><tr><td>port</td><td>k8s 容器之间互相访问的端口</td></tr><tr><td>type</td><td>NodePort，Service的一种访问方式</td></tr></tbody></table><p>在这里，Service的模式我们选择使用 <code>NodePort</code> 模式。其他模式可以参考：www.dockerone.com/article/488…</p><h4 id="与-deployment-配置文件合并" tabindex="-1">与 Deployment 配置文件合并 ​</h4><p>根据YAML语法，我们可以将Service和deployment合并为同一个配置文件。当然，新建一个文件也是可以的。 我们编辑原有的v1.yaml，在文件底部添加 <code>---</code> 继续拼接Service的配置：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span></span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e1aa2469b74e2a94f6e87228958c6e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>编辑保存退出后，使用 <code>kubectl apply</code> 命令来更新配置：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./v1.yaml</span></span></code></pre></div><p>此时，Service 已经部署完毕。</p><h4 id="查看-service-的访问端口" tabindex="-1">查看 Service 的访问端口 ​</h4><p>在部署成功 <code>Service</code> 后，我们可以使用 <code>kubectl get svc</code> 来获取我们已经部署的 <code>Service</code> 列表</p><p>我们可以使用 <code>kubectl get svc</code> 去查看下具体打开的服务端口：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> svc</span></span></code></pre></div><p>执行后，会展示下图。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baf399be5a14033b220377665186fdc~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>其中， <code>PORT</code> 字段代表 <code>Service</code> 的访问端口。: 前为映射到Pod的端口，31048 为访问端口。 我们访问 <code>Master节点IP + 端口</code>，就可以访问到该服务。</p><h3 id="ingress-是什么" tabindex="-1">ingress 是什么 ​</h3><p>在前面，我们部署了 <code>deployment</code> 和 <code>Service</code>，实现了对服务的访问。但是在实际使用中，我们还会根据请求路径前缀的匹配，权重，甚至根据 <code>cookie/header</code> 的值去访问不同的服务。为了达到这种<strong>负载均衡</strong>的效果，我们可以使用 <code>k8s</code> 的另一个组件 —— <code>ingress</code></p><p>在日常开发中，我们经常会遇到路径分流问题。例如当我们访问 <code>/a</code> 时，需要返回A服务的页面。访问 <code>/b</code>，需要返回服务B的页面。这时候，我们就可以使用 <code>k8s</code> 中的 <code>ingress</code> 去实现。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48da1116e435433abd57d187b16cea0a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>在这里，我们选择 <code>ingress-nginx</code>。 <code>ingress-nginx</code> 是基于 <code>nginx</code> 的一个 <code>ingress</code> 实现。当然也可以实现正则匹配路径，流量转发，基于 <code>cookie header</code> 切分流量（灰度发布）。</p><h3 id="部署-ingress" tabindex="-1">部署 ingress ​</h3><p>首先进入 <code>master</code> 节点，下载 <code>ingress</code> 配置文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wget</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/baremetal/deploy.yaml</span></span></code></pre></div><p>接着编辑下部署文件，将 <code>ingress</code> 的 <code>nodePort</code> 端口改为 <code>31234</code> ，以方便后面访问：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./deploy.yaml</span></span></code></pre></div><p>在下图所示位置添加 <code>nodePort</code> 字段为 <code>31234</code> ，https为 <code>31235</code> 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0f9ada785d47fbb17e4190145f0f1f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>接着执行命令使 <code>ingress</code> 生效：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> deploy.yaml</span></span></code></pre></div><p>接下来会自动拉取 <code>ingress</code> 镜像，自动部署 <code>ingress</code> 。可以使用 <code>kubectl</code> 命令查看部署状态：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pods</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress-nginx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -l</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> app.kubernetes.io/name=ingress-nginx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --watch</span></span></code></pre></div><p>如果显示以下信息，则代表部署成功。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e061552e5764ef5a47d3a191a978f87~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><p>输入以下命令，检查配置是否生效：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress-nginx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> svc</span></span></code></pre></div><p>如果看到以下信息，代表生效：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15239d6b9e1f47e1a57fff8f643d134f~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h3 id="配置-ingress" tabindex="-1">配置 ingress ​</h3><h4 id="初识配置文件" tabindex="-1">初识配置文件 ​</h4><p>同样的， <code>ingress</code> 服务的配置也是使用 <code>yaml</code> 文件进行管理。</p><p>我们新建一个 <code>ingress</code> 文件夹，将 <code>ingress</code> 的配置放在里面：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ingress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> base.yaml</span></span></code></pre></div><p>拷贝以下内容进去：</p><div class="language-ymal vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ymal</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>apiVersion: networking.k8s.io/v1</span></span>
<span class="line"><span>kind: Ingress</span></span>
<span class="line"><span>metadata:</span></span>
<span class="line"><span>  name: nginx-demo</span></span>
<span class="line"><span>  annotations:</span></span>
<span class="line"><span>    nginx.ingress.kubernetes.io/rewrite-target: /</span></span>
<span class="line"><span>    kubernetes.io/ingress.class: nginx</span></span>
<span class="line"><span>spec:</span></span>
<span class="line"><span>  rules:</span></span>
<span class="line"><span>  - http:</span></span>
<span class="line"><span>      paths: </span></span>
<span class="line"><span>       - path: /wss</span></span>
<span class="line"><span>         pathType: Prefix</span></span>
<span class="line"><span>         backend:</span></span>
<span class="line"><span>           service:</span></span>
<span class="line"><span>             name: front-service-v1</span></span>
<span class="line"><span>             port:</span></span>
<span class="line"><span>               number: 80</span></span></code></pre></div><p>这是一份简单的 <code>ingress</code> 配置文件。配置主要分三部分：</p><h4 id="annotations" tabindex="-1">annotations ​</h4><p><code>annotations</code> 是 <code>ingress</code> 的主要配置项目，可以用来修改这些配置来修改 <code>ingress</code> 的行为。我们可以通过修改这些配置来实现灰度发布，跨域资源，甚至将 <code>www.abc.com</code> 重定向到 <code>abc.com</code> 。</p><blockquote><p>具体详细配置解释，可以翻阅官网文档：kubernetes.github.io/ingress-ngi…</p></blockquote><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">annotations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    nginx.ingress.kubernetes.io/rewrite-target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span></span></code></pre></div><h4 id="rules" tabindex="-1">rules ​</h4><p><code>rules</code> 是 <code>ingress</code> 配置路径转发规则的地方。 <code>path</code> 可以是一个路径字符串，<strong>也可以是一个正则表达式</strong>。 <code>backend</code> 则是 <code>k8s</code> 的 <code>service</code> 服务， <code>serviceName</code> 是服务名称， <code>servicePort</code> 是服务端口。</p><p>当我们去访问 <code>/wss</code> 时， <code>ingress</code> 就会帮我们调度到 <code>front-service-v1</code> 这个 <code>service</code> 上面。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      paths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/wss</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">         pathType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Prefix</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">         backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">           service</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">             name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">front-service-v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">             port</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">               number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">80</span></span></code></pre></div><p>然后执行命令，使配置项目生效：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">kubectl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apply</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./base.yaml</span></span></code></pre></div><p>访问 http://IP:31234，如果能看到服务页面则代表代表成功：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d418024caea4af8b148f136168e29e1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="image.png" loading="lazy"></p><h3 id="结尾" tabindex="-1">结尾 ​</h3><p>到这里，我们就成功地部署了自己的第一个Kubernetes应用，并实现了访问。</p><p><strong>但是在实际开发中，我们还需要零宕机发布，设置灰度环境等需求。下一章我们就会讲解下，如何使用 <code>Kubernetes</code> 配置你自己的灰度和滚动发布环境</strong></p>`,128),t=[n];function l(d,h,c,o,k,r){return a(),i("div",null,t)}const u=s(p,[["render",l]]);export{m as __pageData,u as default};
